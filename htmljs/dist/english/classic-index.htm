<!DOCTYPE html>

<html lang="en">

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>
        BrewPiLess reporting for duty!
    </title>
    <meta name="apple-mobile-web-app-title" content="BrewPiLess">
    <meta name="apple-mobile-web-app-capable" content="yes">

    <script src="http://cdnjs.cloudflare.com/ajax/libs/dygraph/1.1.1/dygraph-combined.js"></script>
    <script>
        /* Regression.JS */
        /* the librar is embedded for your convenience .*/
        /**
         * @license
         *
         * Regression.JS - Regression functions for javascript
         * http://tom-alexander.github.com/regression-js/
         *
         * copyright(c) 2013 Tom Alexander
         * Licensed under the MIT license.
         *
         * @module regression - Least-squares regression functions for JavaScript
         **/
        ! function(a, b) {
            var c;
            return c = "function" == typeof define && define.amd ? define("regression", b) : "undefined" != typeof module ? module.exports = b() : a.regression = b()
        }(this, function() {
            "use strict";

            function a(a, b) {
                var c = a.reduce(function(a, b) {
                        return a + b[1]
                    }, 0),
                    d = c / a.length,
                    e = a.reduce(function(a, b) {
                        var c = b[1] - d;
                        return a + c * c
                    }, 0),
                    f = a.reduce(function(a, c, d) {
                        var e = b[d],
                            f = c[1] - e[1];
                        return a + f * f
                    }, 0);
                return 1 - f / e
            }

            function b(a, b) {
                var c = 0,
                    d = 0,
                    e = 0,
                    f = 0,
                    g = 0,
                    h = a.length - 1,
                    i = new Array(b);
                for (c = 0; h > c; c++) {
                    for (f = c, d = c + 1; h > d; d++) Math.abs(a[c][d]) > Math.abs(a[c][f]) && (f = d);
                    for (e = c; h + 1 > e; e++) g = a[e][c], a[e][c] = a[e][f], a[e][f] = g;
                    for (d = c + 1; h > d; d++)
                        for (e = h; e >= c; e--) a[e][d] -= a[e][c] * a[c][d] / a[c][c]
                }
                for (d = h - 1; d >= 0; d--) {
                    for (g = 0, e = d + 1; h > e; e++) g += a[e][d] * i[e];
                    i[d] = (a[h][d] - g) / a[d][d]
                }
                return i
            }

            function c(a, b) {
                var c = Math.pow(10, b);
                return Math.round(a * c) / c
            }
            var d, e = 2,
                f = {
                    linear: function(b, d, e) {
                        for (var f, g, h, i = [0, 0, 0, 0, 0], j = b.length, k = 0; j > k; k++) null !== b[k][1] && (i[0] += b[k][0], i[1] += b[k][1], i[2] += b[k][0] * b[k][0], i[3] += b[k][0] * b[k][1], i[4] += b[k][1] * b[k][1]);
                        return g = (j * i[3] - i[0] * i[1]) / (j * i[2] - i[0] * i[0]), h = i[1] / j - g * i[0] / j, f = b.map(function(a) {
                            var b = a[0];
                            return [b, g * b + h]
                        }), {
                            r2: a(b, f),
                            equation: [g, h],
                            points: f,
                            string: "y = " + c(g, e.precision) + "x + " + c(h, e.precision)
                        }
                    },
                    linearthroughorigin: function(b, d, e) {
                        for (var f, g, h = [0, 0], i = 0; i < b.length; i++) null !== b[i][1] && (h[0] += b[i][0] * b[i][0], h[1] += b[i][0] * b[i][1]);
                        return f = h[1] / h[0], g = b.map(function(a) {
                            var b = a[0];
                            return [b, f * b]
                        }), {
                            r2: a(b, g),
                            equation: [f],
                            points: g,
                            string: "y = " + c(f, e.precision) + "x"
                        }
                    },
                    exponential: function(b, d, e) {
                        for (var f, g, h, i, j = [0, 0, 0, 0, 0, 0], k = 0; k < b.length; k++) null !== b[k][1] && (j[0] += b[k][0], j[1] += b[k][1], j[2] += b[k][0] * b[k][0] * b[k][1], j[3] += b[k][1] * Math.log(b[k][1]), j[4] += b[k][0] * b[k][1] * Math.log(b[k][1]), j[5] += b[k][0] * b[k][1]);
                        return f = j[1] * j[2] - j[5] * j[5], g = Math.exp((j[2] * j[3] - j[5] * j[4]) / f), h = (j[1] * j[4] - j[5] * j[3]) / f, i = b.map(function(a) {
                            var b = a[0];
                            return [b, g * Math.exp(h * b)]
                        }), {
                            r2: a(b, i),
                            equation: [g, h],
                            points: i,
                            string: "y = " + c(g, e.precision) + "e^(" + c(h, e.precision) + "x)"
                        }
                    },
                    logarithmic: function(b, d, e) {
                        for (var f, g, h, i = [0, 0, 0, 0], j = b.length, k = 0; j > k; k++) null !== b[k][1] && (i[0] += Math.log(b[k][0]), i[1] += b[k][1] * Math.log(b[k][0]), i[2] += b[k][1], i[3] += Math.pow(Math.log(b[k][0]), 2));
                        return g = (j * i[1] - i[2] * i[0]) / (j * i[3] - i[0] * i[0]), f = (i[2] - g * i[0]) / j, h = b.map(function(a) {
                            var b = a[0];
                            return [b, f + g * Math.log(b)]
                        }), {
                            r2: a(b, h),
                            equation: [f, g],
                            points: h,
                            string: "y = " + c(f, e.precision) + " + " + c(g, e.precision) + " ln(x)"
                        }
                    },
                    power: function(b, d, e) {
                        for (var f, g, h, i = [0, 0, 0, 0], j = b.length, k = 0; j > k; k++) null !== b[k][1] && (i[0] += Math.log(b[k][0]), i[1] += Math.log(b[k][1]) * Math.log(b[k][0]), i[2] += Math.log(b[k][1]), i[3] += Math.pow(Math.log(b[k][0]), 2));
                        return g = (j * i[1] - i[2] * i[0]) / (j * i[3] - i[0] * i[0]), f = Math.exp((i[2] - g * i[0]) / j), h = b.map(function(a) {
                            var b = a[0];
                            return [b, f * Math.pow(b, g)]
                        }), {
                            r2: a(b, h),
                            equation: [f, g],
                            points: h,
                            string: "y = " + c(f, e.precision) + "x^" + c(g, e.precision)
                        }
                    },
                    polynomial: function(d, e, f) {
                        var g, h, i, j, k, l, m, n, o = [],
                            p = [],
                            q = 0,
                            r = 0,
                            s = d.length;
                        for (h = "undefined" == typeof e ? 3 : e + 1, i = 0; h > i; i++) {
                            for (k = 0; s > k; k++) null !== d[k][1] && (q += Math.pow(d[k][0], i) * d[k][1]);
                            for (o.push(q), q = 0, g = [], j = 0; h > j; j++) {
                                for (k = 0; s > k; k++) null !== d[k][1] && (r += Math.pow(d[k][0], i + j));
                                g.push(r), r = 0
                            }
                            p.push(g)
                        }
                        for (p.push(o), m = b(p, h), l = d.map(function(a) {
                                var b = a[0],
                                    c = m.reduce(function(a, c, d) {
                                        return a + c * Math.pow(b, d)
                                    }, 0);
                                return [b, c]
                            }), n = "y = ", i = m.length - 1; i >= 0; i--) n += i > 1 ? c(m[i], f.precision) + "x^" + i + " + " : 1 === i ? c(m[i], f.precision) + "x + " : c(m[i], f.precision);
                        return {
                            r2: a(d, l),
                            equation: m,
                            points: l,
                            string: n
                        }
                    },
                    lastvalue: function(b, d, e) {
                        for (var f = [], g = null, h = 0; h < b.length; h++) null !== b[h][1] && isFinite(b[h][1]) ? (g = b[h][1], f.push([b[h][0], b[h][1]])) : f.push([b[h][0], g]);
                        return {
                            r2: a(b, f),
                            equation: [g],
                            points: f,
                            string: "" + c(g, e.precision)
                        }
                    }
                };
            return d = function(a, b, c, d) {
                var g = "object" == typeof c && "undefined" == typeof d ? c : d || {};
                return g.precision || (g.precision = e), "string" == typeof a ? f[a.toLowerCase()](b, c, g) : null
            }
        });
        /*** end of Regression.JS **/
</script>
    <script>
var JSVERSION = "3.5";

function s_ajax(b) {
    var c = new XMLHttpRequest();
    c.onreadystatechange = function() {
        if (c.readyState == 4) {
            if (c.status == 200) {
                b.success(c.responseText)
            } else {
                c.onerror(c.status)
            }
        }
    };
    c.ontimeout = function() {
        if (typeof b["timeout"] != "undefined") b.timeout();
        else c.onerror(-1)
    }, c.onerror = function(a) {
        if (typeof b["fail"] != "undefined") b.fail(a)
    };
    c.open(b.m, b.url, true);
    if (typeof b["data"] != "undefined") {
        c.setRequestHeader("Content-Type", (typeof b["mime"] != "undefined") ? b["mime"] : "application/x-www-form-urlencoded");
        c.send(b.data)
    } else c.send()
}

var Q = function(d) {
    return document.querySelector(d);
};

function C2F(c) {
    return Math.round((c * 1.8 + 32) * 10) / 10
}

function F2C(f) {
    return Math.round((f - 32) / 1.8 * 10) / 10
}

function openDlgLoading() {
    document.getElementById('dlg_loading').style.display = "block";
}

function closeDlgLoading() {
    document.getElementById('dlg_loading').style.display = "none";
}

var BrewMath = {
    abv: function(og, fg) {
        return ((76.08 * (og - fg) / (1.775 - og)) * (fg / 0.794)).toFixed(1);
    },
    abvP: function(og, fg) {
        return BrewMath.abv(BrewMath.pla2sg(og), BrewMath.pla2sg(fg));
    },
    att: function(og, fg) {
        return Math.round((og - fg) / (og - 1) * 100);
    },
    attP: function(pog, pfg) {
        return Math.round((pog - pfg) / pog * 100);
    },
    sg2pla: function(sg) {
        return (((182.4601 * sg - 775.6821) * sg + 1262.7794) * sg - 669.5622);
    },
    pla2sg: function(pla) {
        return 1 + (pla / (258.6 - ((pla / 258.2) * 227.1)));
    },
    tempCorrectionF(sg, t, c) {
        var nsg = sg * ((1.00130346 - 0.000134722124 * t + 0.00000204052596 * t * t - 0.00000000232820948 * t * t * t) /
            (1.00130346 - 0.000134722124 * c + 0.00000204052596 * c * c - 0.00000000232820948 * c * c * c));
        return nsg;
    },
    pTempCorrectionF(sg, t, c) {
        return BrewMath.sg2pla(BrewMath.tempCorrectionF(BrewMath.pla2sg(sg), t, c));
    },
    tempCorrection(celsius, sg, t, c) {
        return celsius ? BrewMath.tempCorrectionF(sg, C2F(t), C2F(c)) : BrewMath.tempCorrectionF(sg, t, c);
    },
    pTempCorrection(celsius, sg, t, c) {
        return celsius ? BrewMath.pTempCorrectionF(sg, C2F(t), C2F(c)) : BrewMath.tempCorrectionF(sg, t, c);
    }
};

Date.prototype.shortLocalizedString = function() {
    var y = this.getYear() + 1900;
    var re = new RegExp('[^\d]?' + y + '[^\d]?');
    var n = this.toLocaleDateString();
    var ds = n.replace(re, "");
    var HH = this.getHours();
    var MM = this.getMinutes();

    function T(x) {
        return (x > 9) ? x : ("0" + x);
    }
    return ds + " " + T(HH) + ":" + T(MM);
};

function getActiveNavItem() {
    var path = window.location.pathname.split("/").pop();
    if (path == "") path = "index.htm";
    var element = Q('.options>li>a[href="/' + path + '"]');
    element.className += 'active';
}

function formatDate(dt) {
    //	var y = dt.getFullYear();
    //	var M = dt.getMonth() +1;
    //	var d = dt.getDate();
    var h = dt.getHours();
    var m = dt.getMinutes();
    //    var s = dt.getSeconds();
    function dd(n) {
        return (n < 10) ? '0' + n : n;
    }
    //	return dd(M) + "/" + dd(d) + "/" + y +" "+ dd(h) +":"+dd(m)+":"+dd(s);
    //	return dd(M) + "/" + dd(d) +" "+ dd(h) +":"+dd(m);
    return dt.toLocaleDateString() + " " + dd(h) + ":" + dd(m);
}

function formatDateForPicker(date) {
    var h = date.getHours();
    var m = date.getMinutes();

    function dd(n) { return (n < 10) ? '0' + n : n; }
    return date.getFullYear() + "-" + dd(date.getMonth() + 1) + "-" + dd(date.getDate()) + "T" + dd(h) + ":" + dd(m);
}
</script>
    <script>
function invoke(arg) {
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
        if (xhttp.readyState == 4) {
            if (xhttp.status == 200) {
                arg.success(xhttp.responseText);
            } else {
                xhttp.onerror(xhttp.status);
            }
        }
    };
    xhttp.ontimeout = function() {
            if (typeof arg["timeout"] != "undefined")
                arg.timeout();
            else
                xhttp.onerror(-1);
        },
        xhttp.onerror = function(a) {
            if (typeof arg["fail"] != "undefined")
                arg.fail(a);
        };

    xhttp.open(arg.m, arg.url, true);
    if (typeof arg["data"] != "undefined") {
        xhttp.setRequestHeader("Content-Type", (typeof arg["mime"] != "undefined") ? arg["mime"] : "application/x-www-form-urlencoded");
        xhttp.send(arg.data);
    } else
        xhttp.send();
}

var BWF = {
    BrewProfile: "/brewing.json",
    process: function(msg) {
        if (this.raw != null) {
            this.raw(msg);
            return;
        }
        //console.log("rcv:" + msg);
        eval("m={" + msg + "}");
        //	console.log("json:"+m);
        for (var key in m) {
            if (typeof this.handlers[key] != "undefined") {
                this.handlers[key](m[key]);
            }
        }
    },
    on: function(lb, handler) {
        this.handlers[lb] = handler;
    },
    send: function(data) {
        if (this.ws.readyState == 1) this.ws.send(data);
    },
    reconnecting: false,
    connect: function() {
        var me = this;
        if (typeof WebSocket !== "undefined") {
            var ws = new WebSocket('ws://' + document.location.host + '/ws');
            me.ws = ws;
            ws.onopen = function() {
                console.log("Connected");
                me.onconnect();
            };

            ws.onclose = function() {
                if (me.reconnecting) return;
                console.log("WS close");
                me.error(-2);
                if (me.auto) setTimeout(function() { me.reconnect(); }, 5000);
            };

            /*ws.onerror = function() {
                console.log("ws error");
            };*/

            ws.onmessage = function(e) {
                me.process(e.data);
            };
        } else {
            //console.log("not support WebSocket");
            alert("Error! WebSocket Not Supported!");
        }
    },
    reconnect: function(forced) {
        forced = (typeof forced == "undefined") ? false : true;
        var me = this;
        if (me.reconnecting) return;
        if (!forced && me.ws.readyState == 1) return;
        console.log("reconnect forced:" + forced + " state:" + me.ws.readyState);
        me.reconnecting = true;
        me.ws.close();
        // this might triger onerror, and result in "reconnect" call again.
        me.connect();
        me.reconnecting = false;
    },
    init: function(arg) {
        var b = this;
        b.error = (typeof arg.error == "undefined") ? function() {} : arg.error;
        b.handlers = (typeof arg.handlers == "undefined") ? {} : arg.handlers;
        b.raw = (typeof arg.raw == "undefined") ? null : arg.raw;
        b.onconnect = (typeof arg.onconnect == "undefined") ? function() {} : arg.onconnect;
        b.auto = (typeof arg.reconnect == "undefined") ? true : arg.reconnect;

        b.connect();
    },
    save: function(file, data, success, fail) {
        invoke({
            m: "POST",
            url: "/fputs",
            data: "path=" + file + "&content=" + encodeURIComponent(data),
            success: function() { success(); },
            fail: function(e) { fail(e); }
        });
    },
    load: function(file, success, fail) {
        invoke({
            m: "GET",
            url: file,
            success: function(d) { success(d); },
            fail: function(e) { fail(e); }
        });
    }
};
</script>
    <script>
        /* chart.js */
        // gravity tracking
        var GravityFilter = {
            b: 0.1,
            y: 0,
            reset: function() {
                this.y = 0;
            },
            add: function(gravity) {
                if (this.y == 0) this.y = gravity;
                else this.y = this.y + this.b * (gravity - this.y);
                return Math.round(this.y * 10000) / 10000;
            },
            setBeta: function(beta) {
                this.b = beta;
            }
        };
        var GravityTracker = {
            NumberOfSlots: 48,
            InvalidValue: 0xFF,
            ridx: 0,
            record: [],
            threshold: 1,
            setThreshold: function(t) {
                this.threshold = t;
            },
            addRecord: function(v) {
                this.record[this.ridx++] = v;
                if (this.ridx >= this.NumberOfSlots) this.ridx = 0;
            },
            stable: function(duration, to) {
                to = (typeof to == "undefined") ? this.threshold : to;
                var current = this.ridx - 1;
                if (current < 0) current = this.NumberOfSlots - 1;
                var previous = this.NumberOfSlots + this.ridx - duration;
                while (previous >= this.NumberOfSlots) previous -= this.NumberOfSlots;
                return (this.record[previous] - this.record[current]) <= to;
            },
            Period: 60 * 60,
            init: function() {
                this.curerntStart = 0;
                this.lastValue = 0;
            },
            add: function(gravity, time) {
                //gravity = Math.round(fgravity * 1000, 1);
                var timediff = time - this.curerntStart;

                if (timediff > this.Period) {
                    this.addRecord(gravity);
                    if (this.lastValue != 0) {
                        timediff -= this.Period;
                        while (timediff > this.Period) {
                            timediff -= this.Period;
                            this.addRecord(this.lastValue);
                        }
                    }
                    this.curerntStart = time;
                    this.lastValue = gravity;
                }
            }
        };


        function fgstate(duration) {
            var Color = {
                0: "red",
                12: "orange",
                24: "yellow",
                48: "green"
            };
            Q("#fgstate").style.backgroundColor = Color[duration];
        }

        function checkfgstate() {
            if (GravityTracker.stable(12)) {
                if (GravityTracker.stable(24)) {
                    if (GravityTracker.stable(48)) fgstate(48);
                    else fgstate(24); // 24
                } else fgstate(12); // 
            } else fgstate(0);
        }
        // gravity tracking
        var GravityIndex = 6;
        var TiltAngleIndex = 7;
        var RoomTemperatureIndex = 4;

        var BrewChart = function(div) {
            var t = this;
            t.cid = div;
            t.ctime = 0;
            t.interval = 60;
            t.numLine = 7;
            t.numData = 8;
            t.calculateSG = false;
            t.calibrating = false;

            t.lidx = 0;
            t.celius = true;
            t.clearData();
        };
        var colorIdle = "white";
        var colorCool = "rgba(0, 0, 255, 0.4)";
        var colorHeat = "rgba(255, 0, 0, 0.4)";
        var colorWaitingHeat = "rgba(255, 0, 0, 0.2)";
        var colorWaitingCool = "rgba(0, 0, 255, 0.2)";
        var colorHeatingMinTime = "rgba(255, 0, 0, 0.6)";
        var colorCoolingMinTime = "rgba(0, 0, 255, 0.6)";
        var colorWaitingPeakDetect = "rgba(0, 0, 0, 0.2)";
        var STATE_LINE_WIDTH = 15;
        var STATES = [{
            name: "IDLE",
            color: colorIdle,
            text: "Idle"
        }, {
            name: "STATE_OFF",
            color: colorIdle,
            text: "Off"
        }, {
            name: "DOOR_OPEN",
            color: "#eee",
            text: "Door Open",
            doorOpen: true
        }, {
            name: "HEATING",
            color: colorHeat,
            text: "Heating"
        }, {
            name: "COOLING",
            color: colorCool,
            text: "Cooling"
        }, {
            name: "WAITING_TO_COOL",
            color: colorWaitingCool,
            text: "Waiting to Cool",
            waiting: true
        }, {
            name: "WAITING_TO_HEAT",
            color: colorWaitingHeat,
            text: "Waiting to Heat",
            waiting: true
        }, {
            name: "WAITING_FOR_PEAK_DETECT",
            color: colorWaitingPeakDetect,
            text: "Waiting for Peak",
            waiting: true
        }, {
            name: "COOLING_MIN_TIME",
            color: colorCoolingMinTime,
            text: "Cooling Min Time",
            extending: true
        }, {
            name: "HEATING_MIN_TIME",
            color: colorHeatingMinTime,
            text: "Heating Min Time",
            extending: true
        }, {
            name: "INVALID",
            color: colorHeatingMinTime,
            text: "Invalid State"
        }];
        BrewChart.Mode = {
            b: "Beer Constant",
            f: "Fridge Constant",
            o: "Off",
            p: "Profile"
        };
        BrewChart.Colors = ["rgb(240, 100, 100)", "rgb(41,170,41)", "rgb(89, 184, 255)", "rgb(255, 161, 76)", "#AAAAAA", "#f5e127", "rgb(153,0,153)", "#000abb"];
        BrewChart.Labels = ['Time', 'beerSet', 'beerTemp', 'fridgeTemp', 'fridgeSet', 'roomTemp', 'auxTemp', 'gravity', 'filtersg'];
        BrewChart.ClassLabels = ['', 'beer-set', 'beer-temp', 'fridge-temp', 'fridge-set', 'room-temp', 'aux-temp', 'gravity', 'filtersg'];
        var BeerTempLine = 2;
        var BeerSetLine = 1;
        var FridgeTempLine = 3;
        var FridgeSetLine = 4;
        var RoomTempLine = 5;
        var AuxTempLine = 6;
        var GravityLine = 7;
        var FilteredSgLine = 8;

        BrewChart.prototype.clearData = function() {
            this.laststat = [NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN];
            this.sg = NaN;
            this.og = NaN;
        };

        BrewChart.prototype.setCelius = function(c) {
            this.celius = c;
            this.ylabel(STR.ChartLabel + '(' + (c ? "°C" : "°F") + ')');
        };

        BrewChart.prototype.incTime = function() {
            // format time, use hour and minute only.
            this.ctime += this.interval;
            //	console.log("incTime:"+ this.ctime/this.interval);
        };

        BrewChart.prototype.formatDate = function(d) {
            var HH = d.getHours();
            var MM = d.getMinutes();
            var SS = d.getSeconds();

            function T(x) {
                return (x > 9) ? x : ("0" + x);
            }
            return d.toLocaleDateString() + " " + T(HH) + ":" + T(MM) + ":" + T(SS);
        };

        BrewChart.prototype.formatDuration = function(elapsed) {
            var str = "";
            var days = Math.floor(elapsed / 86400);
            if (days > 0) {
                str = days + "d";
                elapsed -= days * 86400;
            }
            var hours = elapsed / 3600;
            str = str + hours.toFixed(1) + "h";
            return str;
        };

        BrewChart.prototype.showLegend = function(date, row) {
            var d = new Date(date);
            Q(".beer-chart-legend-time").innerHTML = this.formatDate(d);
            if (Q(".beer-chart-legend-elapse")) Q(".beer-chart-legend-elapse").innerHTML = this.formatDuration(d.getTime() / 1000 - this.starttime);

            Q(".chart-legend-row.beer-temp .legend-value").innerHTML = this.tempFormat(this.chart.getValue(row, BeerTempLine));
            Q(".chart-legend-row.beer-set .legend-value").innerHTML = this.tempFormat(this.chart.getValue(row, BeerSetLine));
            Q(".chart-legend-row.fridge-temp .legend-value").innerHTML = this.tempFormat(this.chart.getValue(row, FridgeTempLine));
            Q(".chart-legend-row.fridge-set .legend-value").innerHTML = this.tempFormat(this.chart.getValue(row, FridgeSetLine));
            Q(".chart-legend-row.room-temp .legend-value").innerHTML = this.tempFormat(this.chart.getValue(row, RoomTempLine));

            Q(".chart-legend-row.aux-temp .legend-value").innerHTML = this.tempFormat(this.chart.getValue(row, AuxTempLine));

            var g = this.chart.getValue(row, GravityLine);
            Q(".chart-legend-row.gravity .legend-value").innerHTML = (!g || isNaN(g)) ? "--" : (this.plato ? g.toFixed(2) + "&deg;P" : g.toFixed(4));
            var filteredG = this.chart.getValue(row, FilteredSgLine);
            Q(".chart-legend-row.filtersg .legend-value").innerHTML = (!filteredG || isNaN(filteredG)) ? "--" : (this.plato ? filteredG.toFixed(2) + "&deg;P" : filteredG.toFixed(4));

            var state = parseInt(this.state[row]);
            if (!isNaN(state)) {
                Q('.beer-chart-state').innerHTML = STATES[state].text;
            }
        };

        BrewChart.prototype.hideLegend = function() {
            var v = document.querySelectorAll(".legend-value");
            v.forEach(function(val) {
                val.innerHTML = "--";
            });
            Q(".beer-chart-legend-time").innerHTML = this.dateLabel; //"Date/Time";
            Q('.beer-chart-state').innerHTML = "state";
        };

        BrewChart.prototype.tempFormat = function(y) {
            var v = parseFloat(y);
            if (isNaN(v)) return "--";
            var DEG = this.celius ? "&deg;C" : "&deg;F";
            return parseFloat(v).toFixed(2) + DEG;
        };
        BrewChart.prototype.initLegend = function() {
            // init color
            if (Q(".beer-temp .toggle")) {
                for (var i = 1; i < BrewChart.ClassLabels.length; i++) {
                    var label = BrewChart.ClassLabels[i];
                    Q(".chart-legend-row." + label).style.color = BrewChart.Colors[i - 1];
                    Q("." + label + ".toggle").style.backgroundColor = BrewChart.Colors[i - 1];
                }
            }
            this.dateLabel = Q(".beer-chart-legend-time").innerHTML;
        };
        BrewChart.prototype.toggleLine = function(line) {
            this.shownlist[line] = !this.shownlist[line];
            var divclass = BrewChart.ClassLabels[line];
            if (this.shownlist[line]) {
                if (Q("." + divclass + " .toggle")) Q("." + divclass + " .toggle").style.backgroundColor = Q(".chart-legend-row." + divclass).style.color;
                this.chart.setVisibility(line - 1, true);
            } else {
                if (Q("." + divclass + " .toggle")) Q("." + divclass + " .toggle").style.backgroundColor = "transparent";
                this.chart.setVisibility(line - 1, false);
            }
        };
        BrewChart.prototype.setLabels = function(y1, y2) {
            this.ylabel = y1;
            this.y2label = y2;
        };
        BrewChart.prototype.createChart = function() {
            var t = this;
            t.initLegend();
            t.shownlist = [true, true, true, true, true, true, true, true, true];

            var ldiv = document.createElement("div");
            ldiv.className = "hide";
            var ylabel = (t.ylabel ? t.ylabel : 'Temperature') + '(&deg;' + (t.celius ? 'C' : 'F') + ')';
            var y2label = t.y2label ? t.y2label : 'Gravity';
            document.body.appendChild(ldiv);
            var opt = {
                labels: BrewChart.Labels,
                colors: BrewChart.Colors,
                connectSeparatedPoints: true,
                ylabel: ylabel,
                y2label: y2label,
                series: {
                    'gravity': {
                        axis: 'y2',
                        drawPoints: true,
                        pointSize: 2,
                        highlightCircleSize: 4
                    },
                    'filtersg': {
                        axis: 'y2',
                    }
                },
                axisLabelFontSize: 12,
                animatedZooms: true,
                gridLineColor: '#ccc',
                gridLineWidth: '0.1px',
                labelsDiv: ldiv,
                labelsDivStyles: {
                    'display': 'none'
                },
                displayAnnotations: true,
                //showRangeSelector: true,
                strokeWidth: 1,
                axes: {
                    y: {
                        valueFormatter: function(y) {
                            return t.tempFormat(y);
                        }
                    },
                    y2: {
                        valueFormatter: function(y) {
                            return t.plato ? y.toFixed(1) : y.toFixed(3);
                        },
                        axisLabelFormatter: function(y) {
                            var range = this.yAxisRange(1);
                            if (t.plato) return (range[1] - range[0] > 1) ? y.toFixed(1) : y.toFixed(2);

                            if (range[1] - range[0] > 0.002)
                                return y.toFixed(3).substring(1);
                            else
                                return y.toFixed(4).substring(2);
                        }
                    }
                },
                highlightCircleSize: 2,
                highlightSeriesOpts: {
                    strokeWidth: 1.5,
                    strokeBorderWidth: 1,
                    highlightCircleSize: 5
                },
                highlightCallback: function(e, x, pts, row) {
                    t.showLegend(x, row);
                },
                unhighlightCallback: function(e) {
                    t.hideLegend();
                },
                underlayCallback: function(ctx, area, graph) {
                        ctx.save();
                        try {
                            t.drawBackground(ctx, area, graph);
                        } finally {
                            ctx.restore();
                        }
                    }
                    /*                drawCallback: function(beerChart, is_initial) {
                                        if (is_initial) {
                                            if (t.anno.length > 0) {
                                                t.chart.setAnnotations(t.anno);
                                            }
                                        }
                                    }*/
            };
            t.chart = new Dygraph(document.getElementById(t.cid), t.data, opt);
        };

        BrewChart.prototype.findNearestRow = function(g, time) {
            "use strict";
            var low = 0,
                high = g.numRows() - 1;
            var mid, comparison;

            while (low < high) {
                mid = Math.floor((low + high) / 2);
                comparison = g.getValue(mid, 0) - time;
                if (comparison < 0) {
                    low = mid + 1;
                    continue;
                }
                if (comparison > 0) {
                    high = mid - 1;
                    continue;
                }
                return mid;
            }
            return low;
        };
        BrewChart.prototype.findStateBlocks = function(g, start, end) {
            "use strict";
            var result = [];
            var state = this.state[start]; //getState(g, start);             // current state
            var newState;
            for (var i = start; i < end; i++) { // find the next change
                newState = this.state[i]; //getState(g, i);
                if (newState !== state) {
                    result.push({
                        row: i,
                        state: state
                    });
                    state = newState;
                }
            }
            result.push({
                row: end,
                state: state
            });
            return result;
        };
        BrewChart.prototype.getTime = function(g, row) {
            "use strict";
            if (row >= g.numRows()) {
                row = g.numRows() - 1;
            }
            return g.getValue(row, 0);
        };
        BrewChart.prototype.drawBackground = function(ctx, area, graph) {
            var timeStart = graph.toDataXCoord(area.x);
            var timeEnd = graph.toDataXCoord(area.x + area.w);
            // the data rows for the range we are interested in. 0-based index. This is deliberately extended out one row
            // to be sure the range is included
            var rowStart = Math.max(this.findNearestRow(graph, timeStart) - 1, 0);
            var rowEnd = this.findNearestRow(graph, timeEnd) + 1;
            if (rowStart === null || rowEnd === null) {
                return;
            }
            var blocks = this.findStateBlocks(graph, rowStart, rowEnd); // rowEnd is exclusive

            var startX = 0; // start drawing from 0 - the far left
            for (var i = 0; i < blocks.length; i++) {
                var block = blocks[i];
                var row = block.row; // where this state run ends
                var t = this.getTime(graph, row); // convert to time. Using time ensures the display matches the plotted resolution
                // of the graph.
                var r = (t - timeStart) / (timeEnd - timeStart); // as a fraction of the entire display
                var endX = Math.floor(area.x + (area.w * r));

                var state = STATES[parseInt(block.state, 10)];
                if (state === undefined) {
                    state = STATES[0];
                }
                //var borderColor = (state.waiting || state.extending) ? setAlphaFactor(state.color, 0.5) : undefined;
                //var bgColor = (state.waiting) ? bgColor = colorIdle : state.color;
                ctx.fillStyle = state.color;
                ctx.fillRect(startX, area.h - STATE_LINE_WIDTH, endX - startX, area.h);
                startX = endX;
            }
        };
        BrewChart.prototype.addMode = function(m, x) {
            var s = String.fromCharCode(m);
            this.anno.push({
                series: "beerTemp",
                x: x,
                shortText: s.toUpperCase(),
                text: BrewChart.Mode[s],
                attachAtBottom: true
            });
        };

        BrewChart.testData = function(data) {
            if (data[0] != 0xFF) return false;
            var s = data[1] & 0x07;
            if (s != 5) return false;

            return {
                sensor: s,
                f: data[1] & 0x10
            };
        };

        BrewChart.prototype.addResume = function(delta) {
            this.anno.push({
                series: "beerTemp",
                x: this.ctime * 1000,
                shortText: 'R',
                text: 'Resume',
                attachAtBottom: true
            });
        };

        BrewChart.prototype.getTiltAround = function(idx) {
            var t = this;
            var left = -1;
            var right = -1;

            if (t.angles[idx] != null) return [t.angles[idx], t.data[idx][AuxTempLine]];

            for (var i = idx - 1; i >= 0; i--) {
                if (t.angles[i] != null) {
                    left = i;
                    break;
                }
            }
            for (var i = idx + 1; i < t.angles.length > 0; i++) {
                if (t.angles[i] != null) {
                    right = i;
                    break;
                }
            }
            if (left < 0 && right < 0) return null;
            if (left < 0) return [t.angles[right], t.data[right][AuxTempLine]];
            if (right < 0) return [t.angles[left], t.data[left][AuxTempLine]];
            return [t.angles[left] + (t.angles[right] - t.angles[left]) / (right - left) * (idx - left),
                (t.data[left][AuxTempLine] + t.data[right][AuxTempLine]) / 2
            ];
        };

        BrewChart.prototype.getCalibration = function() {
            var pairs = [];
            for (var i = 0; i < this.data.length; i++) {
                if (this.data[i][GravityLine]) {
                    var data = this.getTiltAround(i);
                    // corrected the reading into current beer data
                    if (data) {
                        var beerTemp = this.celius ? C2F(data[1]) : data[1];
                        var gravity = this.data[i][GravityLine];
                        var converted;
                        if (this.plato)
                            converted = BrewMath.sg2pla(BrewMath.tempCorrectionF(BrewMath.pla2sg(gravity), C2F(this.coTemp), beerTemp));
                        else converted = BrewMath.tempCorrectionF(gravity, C2F(this.coTemp), beerTemp);
                        pairs.push([data[0], converted]);
                    }
                }
            }
            pairs.push([this.tiltInWater, this.readingInWater]);
            return pairs;
        };
        BrewChart.prototype.filterPoints = function(points, mask) {
            var nps = [];
            for (var i = 0; i < points.length; i++) {
                if (!(mask & (0x1 << i))) nps.push(points[i]);
            }
            return nps;
        };

        BrewChart.prototype.setIgnoredMask = function(mask) {
            if (this.cal_igmask == mask) return false;
            this.cal_igmask = mask;
            return true;
        };

        BrewChart.prototype.getFormula = function() {
            var points = this.getCalibration();
            if (points.length < 2) return;
            var cpoints = this.filterPoints(points, this.cal_igmask);
            if (cpoints.length < 2) {
                cpoints = points;
                this.cal_igmask = 0;
            }
            var poly = regression('polynomial', cpoints, (cpoints.length > 3) ?
                3 : ((cpoints.length > 2) ? 2 : 1), {
                    precision: 9
                });
            this.calibrationPoints = points;
            //this.equation = poly.equation;
            this.calculateSG = true;

            this.sgByTilt = (cpoints.length > 3) ?
                function(x) {
                    return poly.equation[0] +
                        poly.equation[1] * x +
                        poly.equation[2] * x * x +
                        poly.equation[3] * x * x * x;
                } : ((cpoints.length > 2) ? function(x) {
                    return poly.equation[0] +
                        poly.equation[1] * x +
                        poly.equation[2] * x * x;
                } : function(x) {
                    return poly.equation[0] +
                        poly.equation[1] * x;
                });

            this.coefficients = (cpoints.length > 3) ? [poly.equation[0], poly.equation[1], poly.equation[2], poly.equation[3]] :
                ((cpoints.length > 2) ? [poly.equation[0], poly.equation[1], poly.equation[2], 0] : [poly.equation[0], poly.equation[1], 0, 0]);
            this.npt = points.length;
        };
        BrewChart.prototype.process = function(data) {
            var newchart = false;
            var sgPoint = false;
            var t = this;
            //t.raw = data;
            t.filterSg = null;
            for (var i = 0; i < data.length;) {
                var d0 = data[i++];
                var d1 = data[i++];
                if (d0 == 0xFF) { // header. 
                    if ((d1 & 0xF) != 5) {
                        alert("Log version mismatched!");
                        return;
                    }
                    //console.log(""+t.ctime/t.interval +" header");
                    t.celius = (d1 & 0x10) ? false : true;
                    t.calibrating = (d1 & 0x20) ? false : true;
                    t.plato = (d1 & 0x40) ? false : true;

                    var p = data[i++];
                    p = p * 256 + data[i++];
                    t.interval = p;
                    // 
                    t.starttime = (data[i] << 24) + (data[i + 1] << 16) + (data[i + 2] << 8) + data[i + 3];
                    t.ctime = t.starttime;
                    i += 4;
                    t.data = [];
                    t.anno = [];
                    t.state = [];
                    t.angles = [];
                    t.rawSG = [];
                    t.cstate = 0;
                    t.coTemp = 20;
                    t.cal_igmask = 0;
                    this.clearData();
                    newchart = true;
                    // gravity tracking
                    GravityFilter.reset();
                    GravityTracker.init();
                    // gravity tracking
                } else if (d0 == 0xF3) { // correction temperature
                    t.coTemp = d1; // always celisus
                } else if (d0 == 0xF4) { // mode
                    //console.log(""+t.ctime/t.interval +" Stage:"+d1);
                    t.addMode(d1, t.ctime * 1000);
                } else if (d0 == 0xF1) { // state
                    t.cstate = d1;
                } else if (d0 == 0xFE) { // resume
                    t.lidx = 0;
                    var d2 = data[i++];
                    var d3 = data[i++];
                    var tdiff = d3 + (d2 << 8) + (d1 << 16);
                    if(tdiff > 30*24*60*60) tdiff= 30*60; // it's wrong if it's too long.
                    var ntime = t.starttime + tdiff;
                    if (ntime > t.ctime) {
                        // add a gap to it                   
                        t.data.push([new Date(t.ctime * 1000), NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN]);
                        t.state.push(null);
                        t.angles.push(null);
                        t.rawSG.push[null];

                        if (ntime - t.ctime > t.interval)
                            t.ctime = ntime;
                        else
                            t.ctime += t.interval;
                    }
                    t.addResume(d1);
                    // drop the data
                    /*
                    if (t.lidx) {
                        var idx;
                        for (idx = t.lidx; idx < t.numLine; idx++) t.dataset.push(NaN);
                        t.data.push(t.dataset);
                        t.state.push(null);
                        t.angles.push(null);
                        t.rawSG.push[null];
                    }*/

                } else if (d0 == 0xF8) { //OG
                    var hh = data[i++];
                    var ll = data[i++];
                    var v = (hh & 0x7F) * 256 + ll;
                    t.og = t.plato ? v / 100 : v / 10000;
                } else if (d0 == 0xFA) { //Ignored mask
                    var b2 = data[i++];
                    var b3 = data[i++];
                    t.cal_igmask = (d1 << 14) + (b2 << 7) + b3;
                } else if (d0 == 0xF9) { //Tilt in water
                    var hh = data[i++];
                    var ll = data[i++];
                    var v = (hh & 0x7F) * 256 + ll;
                    t.tiltInWater = v / 100;
                    //
                    if (t.plato) t.readingInWater = 0;
                    else t.readingInWater = (d1 == 0) ? 1.0 : (0.9 + d1 / 1000);
                } else if (d0 == 0xF0) { // record
                    t.changes = d1;
                    t.lidx = 0;
                    var d = new Date(this.ctime * 1000);
                    //t.incTime(); // add one time interval
                    t.dataset = [d];
                    t.processRecord();
                } else if (d0 < 128) { // temp. or gravity
                    var tp = d0 * 256 + d1;
                    if (t.lidx == GravityIndex) {
                        tp = (tp == 0x7FFF) ? NaN : (t.plato ? tp / 100 : ((tp > 8000) ? tp / 10000 : tp / 1000));
                        sgPoint = true;
                        // gravity tracking
                    } else if (t.lidx == TiltAngleIndex) {
                        tp = (tp == 0x7FFF) ? NaN : (tp / 100);
                    } else {
                        tp = (tp == 0x7FFF) ? NaN : tp / 100;
                        if (tp >= 225) tp = 225 - tp;
                    }

                    if (t.lidx < t.numData) {
                        if (typeof t.dataset != "undefined") {
                            t.dataset.push(tp);
                            t.laststat[t.lidx] = tp;
                            t.lidx++;
                            t.processRecord();
                        } else {
                            console.log("Error: missing tag.");
                        }
                    } else {
                        console.log("Error: data overlap?");
                    }
                }
            }
            return {
                nc: newchart,
                sg: sgPoint
            };
        };
        BrewChart.prototype.getXRange = function() {
            if (typeof this.chart == "undefined") return [0, 0];
            return this.chart.xAxisRange();
        };
        BrewChart.prototype.setXRange = function(range) {
            if (typeof this.chart == "undefined") return;
            this.chart.updateOptions({ dateWindow: range });
        };
        BrewChart.prototype.updateChart = function() {
            var t = this;
            if (typeof t.chart == "undefined") t.createChart();
            else t.chart.updateOptions({
                'file': t.data
            });
            t.chart.setAnnotations(t.anno);
        };
        BrewChart.prototype.processRecord = function() {
            var t = this;
            while ((((1 << t.lidx) & t.changes) == 0) && t.lidx < t.numData) {
                t.dataset.push((t.lidx > RoomTemperatureIndex) ? null : t.laststat[t.lidx]);
                t.lidx++;
            }
            if (t.lidx >= t.numData) {
                var dataset = t.dataset.slice(0, 8);
                var rawSG = t.dataset[GravityLine];
                // gravity tracking
                var sg = NaN;
                if (!t.calculateSG && t.dataset[GravityLine] != null) {
                    sg = t.dataset[GravityLine];
                } else if (t.calculateSG) {
                    // data field #8 is tilt in source data
                    if (t.dataset[8] == null) dataset[GravityLine] = null;
                    else {
                        var temp = (this.celius) ? C2F(dataset[AuxTempLine]) : dataset[AuxTempLine];
                        sg = t.sgByTilt(t.dataset[8]);

                        if (t.plato) {
                            sg = BrewMath.sg2pla(BrewMath.tempCorrectionF(BrewMath.pla2sg(sg), temp, C2F(t.coTemp)));
                        }
                        dataset[GravityLine] = sg;
                    }
                }
                if (!isNaN(sg)) {
                    t.sg = sg;
                    t.filterSg = GravityFilter.add(sg);
                    if (t.plato)
                        GravityTracker.add(Math.round(t.filterSg * 10), t.ctime);
                    else
                        GravityTracker.add(Math.round(t.filterSg * 1000), t.ctime);
                }

                if (!isNaN(t.sg)) dataset.push(t.filterSg);
                else dataset.push(null);

                t.data.push(dataset);
                t.state.push(t.cstate);
                t.angles.push(t.dataset[8]);
                t.rawSG.push(rawSG);
                t.incTime(); // add one time interval
            }
        };
        /* end of chart.js */
</script>
    <script>
    /* ispindel calibration */
    var PolyRegression = {
        allpoints: [],
        clear: function() {
            var tbody = document.getElementById("pointlist").getElementsByTagName("tbody")[0];
            var rl = tbody.querySelectorAll("tr.pl_calpoint");
            var count = rl.length;
            for (var i = rl.length - 1; i >= 0; i--) {
                var tr = rl[i];
                tr.parentNode.removeChild(tr);
            }
            return tbody;
        },
        newrow: function(values) {
            var tr = this.row.cloneNode(true);

            var td2 = tr.querySelector("td.pl_tilt");
            td2.innerHTML = values[0].toFixed(2);

            var td4 = tr.querySelector("td.pl_sg");
            td4.innerHTML = this.plato ? values[1].toFixed(2) : values[1].toFixed(4); // BrewMath.brix2sg(this.points[i][1]).toFixed(3);

            var td6i = tr.querySelector("td.pl_value");
            td6i.innerHTML = this.plato ? values[2].toFixed(2) : values[2].toFixed(4);

            var td6 = tr.querySelector("td.pl_error");
            td6.innerHTML = this.plato ? values[3].toFixed(2) : (values[3] * 1000).toFixed(1);

            var ig_input = tr.querySelector("input.pl_ignored_cb");
            ig_input.checked = values[4];
            var t = this;
            ig_input.onchange = function() { t.igchanged(this); };
            return tr;
        },
        igchanged: function(checkbox) {
            var tbody = document.getElementById("pointlist").getElementsByTagName("tbody")[0];
            var ilist = tbody.querySelectorAll("input.pl_ignored_cb");
            var mask = 0;
            var notignored = 0;
            for (var i = 0; i < ilist.length; i++) {
                if (ilist[i].checked) mask = mask | (0x1 << i);
                else notignored++;
            }
            if (notignored < 2) {
                console.log("less than 2.");
                checkbox.checked = false;
            } else {
                this.cal_igmask = mask;
                this.show();
            }
        },
        show: function() {
            if (!this.row) {
                this.row = Q("#pointlist tr.pl_calpoint");
                this.row.parentNode.removeChild(this.row);
            }
            this.getFormula();
            var tbody = this.clear();
            for (var i = 0; i < this.ptlist.length; i++) {
                tbody.appendChild(this.newrow(this.ptlist[i]));
            }
            this.chart();
        },
        getFormula: function() {
            var t = this;
            if (t.allpoints.length < 2) return;
            t.points = [];
            for (var i = 0; i < t.allpoints.length; i++) {
                if (!((0x1 << i) & t.cal_igmask)) t.points.push(t.allpoints[i]);
            }
            if (t.points.length < 2) {
                // ignore too much. ignore the ignore
                t.points = t.alpoints;
                t.cal_igmask = 0;
            }

            var poly = regression('polynomial', t.points, (t.points.length > 3) ? 3 : ((t.points.length > 2) ? 2 : 1), {
                precision: 9
            });
            t.regression = poly;
            Q("#polynormial").innerHTML = poly.string;
            // caluate errors

            t.sgByTilt = (t.points.length > 3) ?
                function(x) {
                    return poly.equation[0] +
                        poly.equation[1] * x +
                        poly.equation[2] * x * x +
                        poly.equation[3] * x * x * x;
                } : ((t.points.length > 2) ? function(x) {
                    return poly.equation[0] +
                        poly.equation[1] * x +
                        poly.equation[2] * x * x;
                } : function(x) {
                    return poly.equation[0] +
                        poly.equation[1] * x;
                });

            var point_list = [];

            for (var i = 0; i < t.allpoints.length; i++) {
                var tilt = t.allpoints[i][0];
                var realsg = t.allpoints[i][1];
                var cal_sg = t.sgByTilt(tilt);
                var error = realsg - cal_sg;
                var ignored = ((0x1 << i) & t.cal_igmask) != 0;
                point_list.push([tilt, realsg, cal_sg, error, ignored]);
            }
            t.ptlist = point_list;
        },
        chart: function() {
            var data = [];
            for (var i = 0; i < this.allpoints.length; i++) {
                data.push([this.ptlist[i][0], this.ptlist[i][1], this.ptlist[i][2]]);
            }
            if (typeof this.graph == "undefined") {
                this.graph = new Dygraph(
                    document.getElementById("graph"), data, {
                        labels: ["Tilt", "SG", "Interpolated"],
                        colors: ["rgb(240, 100, 100)", "rgb(89, 184, 255)"],
                        series: {
                            'SG': {
                                drawPoints: true,
                                pointSize: 4,
                                strokeWidth: 0
                            }
                        },
                        axisLabelFontSize: 12,
                        gridLineColor: '#ccc',
                        gridLineWidth: '0.1px',
                        strokeWidth: 1,
                        xRangePad: 10,
                        axes: {
                            y: {
                                axisLabelWidth: 40,
                                axisLabelFormatter: function(y) {
                                    return y.toFixed(3);
                                },
                                valueFormatter: function(y) {
                                    return y.toFixed(3);
                                }
                            },
                            x: {
                                pixelsPerLabel: 30,
                                axisLabelWidth: 40
                            }
                        }
                    }
                );
            } else {
                this.graph.updateOptions({
                    'file': data
                });
                this.graph.resize();
            }
        }
    };

    function applyIgnoreMask() {
        BChart.setIgnoredMask(PolyRegression.cal_igmask);
    }

    function openpolynomialpane() {
        Q("#polynomialpane").style.display = "block";
        PolyRegression.allpoints = BChart.chart.calibrationPoints;
        PolyRegression.cal_igmask = BChart.chart.cal_igmask;
        PolyRegression.plato = BChart.chart.plato;
        PolyRegression.show();
    }

    function closepolynomialpane() {
        Q("#polynomialpane").style.display = "none";
    }
    /* end of calibration */
</script>
    <script>
function TabPane(modes) {
    var t = this;
    t.cmode = null;

    function dselect(m) {
        var d = document.getElementById(m + "-m");
        //        var nc = document.getElementById(m + "-m").className.replace(/\snav-selected/, '');
        var nc = d.className.replace(/\snav-selected/, '');
        d.className = nc;

        document.getElementById(m + "-s").style.display = "none";
    }

    function select(m) {
        var d = document.getElementById(m + "-m");
        if (d.className.indexOf("nav-selected") < 0)
            d.className += ' nav-selected';

        document.getElementById(m + "-s").style.display = "block";
        t.cmode = m;
    }

    for (var i = 0; i < modes.length; i++) {
        var m = modes[i];
        document.getElementById(m + "-s").style.display = "none";
        document.getElementById(m + "-m").onclick = function() {
            var tm = this.id.replace(/-m$/, '');
            //deselect current selected 
            dselect(t.cmode);
            // select current
            select(tm);
            return false;
        };
    }
    // select the first one
    select(modes[0]);
    t.select = select;
}

var Capper = {
    target_psi: 0,
    psi_valid: false,
    hidepset: function(hide) {
        this.psi_valid = !hide;
        var psets = document.querySelectorAll(".psi-set-group");
        for (var i = 0; i < psets.length; i++) {
            psets[i].style.display = hide ? "none" : "block";
        }
    },
    setpsi: function(psi) {
        this.target_psi = psi;
        var psets = document.querySelectorAll(".cappressure");
        for (var i = 0; i < psets.length; i++) {
            psets[i].value = psi;
        }
    },
    init: function() {
        var t = this;
        // three conditions:
        //  classic, info-pane within capper-frame
        //  Tom's : info-pane only in index.htm
        //  Tom's UI: capper-frame(control) in control.htm

        var cp = Q(".capping-info-pane");
        if (cp) {
            // classic or Tom's index.htm, do no harm in classic
            cp.style.display = "none";
        }

        var cf = Q("#capper-frame");
        if (cf) {
            // classic or Tom's control.htm
            cf.style.display = "none";
            t.initCtrl();
        }
    },
    initCtrl: function() {
        var t = this;
        t.tabs = new TabPane(["tab-gravity", "tab-time", "tab-manual"]);
        var date_in = Q("#captimeinput");
        t.time = new Date();
        date_in.onchange = function() {
            var nd = new Date(date_in.value);
            if (isNaN(nd.getTime())) {
                // console.log("invalid date");
                t.setInputTime(t.time);
            } else {
                t.setInputTime(nd);
            }
        };
        Q("#cap-apply").onclick = function() {
            // get psi when needed
            var psiarg = t.psi_valid ? "psi=" + t.target_psi + "&" : "";

            var mode = t.tabs.cmode;
            if (mode == "tab-gravity") {
                var sg = Q("#capgravityinput").value;
                /*if (isNaN(sg) || sg > 2 || sg < 0.8) alert("Invalid Gravity");
                else*/
                t.send(psiarg + "sg=" + sg);
            } else if (mode == "tab-time") {
                var time = new Date(Q("#captimeinput").value);
                if (isNaN(time.getTime())) {
                    alert("Invalid Time");
                    return;
                } else t.send(psiarg + "at=" + (time.getTime() / 1000));
            } else {
                if (Q("#capswitch").checked) t.send(psiarg + "cap=1");
                else t.send(psiarg + "cap=0");
            }
        };
        t.hidepset(true);
        var psets = document.querySelectorAll(".cappressure");
        for (var i = 0; i < psets.length; i++) {
            psets[i].onchange = function() {
                t.setpsi(this.value);
            };
        }
    },
    send: function(arg) {
        console.log("send " + arg);
        s_ajax({
            url: "cap?" + arg,
            m: "GET",
            success: function(b) {
                alert("Done!");
            },
            fail: function(a) {
                alert("failed to set capper");
            }
        })

    },
    setcap: function(capped) {
        if (!Q("#capstate-open")) return;
        if (capped) {
            Q("#capstate-open").style.display = "none";
            Q("#capstate-close").style.display = "inline-block";
        } else {
            Q("#capstate-open").style.display = "inline-block";
            Q("#capstate-close").style.display = "none";
        }
    },
    setInputTime: function(d) {
        this.time = d;
        var date_in = Q("#captimeinput");
        date_in.value = (date_in.type == "datetime-local") ? formatDateForPicker(d) : formatDate(d);
    },
    status: function(capst) {
        // first set cap
        //0: none, 1: open, 2: close, 3:time, 4: gravity
        //  might need to hide the DOM, but a reload will solve this. just save some code
        if (typeof capst["m"] == "undefined" || capst.m == 0) return;

        this.statusInfo(capst);
        this.updateCtrl(capst);
    },
    statusInfo: function(capst) {
        // cap status
        var cp = Q(".capping-info-pane");
        if (cp) {
            cp.style.display = "block";

            this.setcap(capst["c"]);
            // info: cap condition
            var IDs = ["", "cs-manopen", "cs-mancap", "cs-timecon", "cs-sgcon"];
            for (var i = 1; i < IDs.length; i++) {
                if (i == capst.m) Q("#" + IDs[i]).style.display = "inline-block";
                else Q("#" + IDs[i]).style.display = "none";
            }

            if (typeof capst["g"] != "undefined")
                Q("#capgravityset").innerHTML = capst["g"];

            if (typeof capst["t"] != "undefined")
                Q("#captimeset").innerHTML = formatDate(new Date(capst["t"] * 1000));
        }
    },
    updateCtrl: function(capst) {
        // cap control
        var cf = Q("#capper-frame");
        if (cf) {
            cf.style.display = "block";

            if (typeof capst["g"] != "undefined")
                Q("#capgravityinput").value = capst["g"];

            if (typeof capst["t"] != "undefined")
                this.setInputTime(new Date(capst["t"] * 1000));
            else
                this.setInputTime(new Date());

            // check mode
            if (capst.m == 1) Q("#capswitch").checked = false;
            else if (capst.m == 2) Q("#capswitch").checked = true;
            // pressure control mode
            if (capst.pm == 2) {
                this.hidepset(false);
                this.setpsi(capst.psi);
            }
        }
    }
};
</script>
    <script>
var BPURL = "/tschedule";
var MAX_STEP = 7;

function formatDate(dt) {
    //	var y = dt.getFullYear();
    //	var M = dt.getMonth() +1;
    //	var d = dt.getDate();
    var h = dt.getHours();
    var m = dt.getMinutes();
    //    var s = dt.getSeconds();
    function dd(n) {
        return (n < 10) ? '0' + n : n;
    }
    //	return dd(M) + "/" + dd(d) + "/" + y +" "+ dd(h) +":"+dd(m)+":"+dd(s);
    //	return dd(M) + "/" + dd(d) +" "+ dd(h) +":"+dd(m);
    return dt.toLocaleDateString() + " " + dd(h) + ":" + dd(m);
}

function formatDateForPicker(date) {
    var h = date.getHours();
    var m = date.getMinutes();

    function dd(n) { return (n < 10) ? '0' + n : n; }
    return date.getFullYear() + "-" + dd(date.getMonth() + 1) + "-" + dd(date.getDate()) + "T" + dd(h) + ":" + dd(m);
}
/* profile.js */
var profileEditor = {
    dirty: false,
    tempUnit: 'C',
    C_startday_Id: "#startdate",
    C_savebtn_Id: "savebtn",
    markdirty: function(d) {
        this.dirty = d;
        document.getElementById(this.C_savebtn_Id).innerHTML = (d) ? "Save*" : "Save";
    },
    getStartDate: function() {
        return this.sd;
    },
    setStartDate: function(d) {
        this.sd = d;
        var date_in = Q(this.C_startday_Id);
        date_in.value = (date_in.type == "datetime-local") ? formatDateForPicker(d) : formatDate(d);
    },
    startDayChange: function() {
        var nd = new Date(Q(this.C_startday_Id).value);
        if (isNaN(nd.getTime())) {
            // console.log("invalid date");
            this.setStartDate(this.sd);
        } else {
            // console.log(nd);
            this.sd = nd;
            this.reorg();
            this.markdirty(true);
        }
    },
    startnow: function() {
        var d = new Date();
        this.setStartDate(d);
        this.reorg();
        this.markdirty(true);
    },
    rowList: function() {
        var tb = document.getElementById("profile_t").getElementsByTagName("tbody")[0];
        return tb.getElementsByTagName("tr");
    },
    sgChange: function(td) {
        if (!isNaN(td.innerHTML) || td.innerHTML.match(/^[\d]+%$/) || td.innerHTML == "") {
            td.saved = td.innerHTML;
            this.markdirty(true);
        } else {
            td.innerHTML = td.saved;
        }
    },
    dayChange: function(td) {
        if (td.innerHTML == "" || isNaN(td.innerHTML))
            td.innerHTML = td.saved;
        else {
            this.markdirty(true);
            this.reorg();
            ControlChart.update(this.chartdata(), this.tempUnit);
        }
    },
    tempChange: function(td) {
        if (td.innerHTML == "" || isNaN(td.innerHTML))
            td.innerHTML = td.saved;
        else {
            this.markdirty(true);
            ControlChart.update(this.chartdata(), this.tempUnit);
        }
    },
    stableChange: function(td) {
        if (td.innerHTML.match(/^\s*(\d+)@(\d+)\s*$/)) {
            td.saved = td.innerHTML;
            this.markdirty(true);
        } else if (!isNaN(td.innerHTML)) {
            td.saved = parseInt(td.innerHTML);
            this.markdirty(true);
        } else {
            td.innerHTML = td.saved;
        }
    },
    initrow: function(tr, stage) {
        var b = this;
        // temp setting
        var type = stage.c;
        tr.type = type;
        var tdTemp = tr.getElementsByClassName("stage-temp")[0];

        if (type == "r") {
            tdTemp.innerHTML = "";
        } else {
            tdTemp.innerHTML = stage.t;
            tdTemp.contentEditable = true;
            tdTemp.onblur = function() {
                b.tempChange(this);
            };
            tdTemp.onfocus = function() {
                this.saved = this.innerHTML;
            };
        }
        // day setting
        var tdDay = tr.getElementsByClassName("stage-time")[0];
        tdDay.innerHTML = stage.d;
        tdDay.contentEditable = true;
        tdDay.onblur = function() {
            b.dayChange(this);
        };
        tdDay.onfocus = function() {
            this.saved = this.innerHTML;
        };

        // stable setting
        var tdStable = tr.getElementsByClassName("stage-stabletime")[0];
        // sg. only valid for hold
        var tdSG = tr.getElementsByClassName("stage-sg")[0];

        if (type == "r") {
            tdSG.innerHTML = "";
            tdStable.innerHTML = "";
        } else {
            tdSG.saved = stage.g;
            tdSG.innerHTML = (typeof stage.g == "undefined") ? "" : stage.g;
            tdSG.contentEditable = true;
            tdSG.onblur = function() {
                b.sgChange(this);
            };
            tdSG.onfocus = function() {
                this.saved = this.innerHTML;
            };
            if (typeof stage.s == "undefined") tdStable.innerHTML = "";
            else tdStable.innerHTML = (typeof stage.x == "undefined") ? stage.s : stage.x + "@" + stage.s;
            tdStable.contentEditable = true;
            tdStable.onblur = function() {
                b.stableChange(this);
            };
            tdStable.onfocus = function() {
                this.saved = this.innerHTML;
            };
        }


        var forTime = tr.getElementsByClassName("for-time")[0];
        // condition, only valid for hold
        var conSel = tr.getElementsByClassName("condition")[0];
        /*
           <option value="t" 0>Time</option>
           <option value="g" 1>SG</option>
           <option value="s" 2>Stable</option>
           <option value="a" 3>Time & SG</option>
           <option value="o" 4>Time OR SG</option>
           <option value="u" 5>Time OR Stable</option>
           <option value="v" 6>Time & Stable</option>
            <option value="b" 7>SG OR Stable</option>
            <option value="x" 8>SG & Stable</option>
            <option value="w" 9>ALL</option>
            <option value="e" 10>Either</option>
        */
        var condtionIndex = {
            t: 0,
            g: 1,
            a: 3,
            s: 2,
            o: 4,
            u: 5,
            v: 6,
            b: 7,
            x: 8,
            w: 9,
            e: 10
        };
        if (type == "r") {
            forTime.style.display = "block";
            conSel.style.display = "none";

        } else {
            conSel.value = stage.c;
            conSel.selectedIndex = condtionIndex[stage.c];

            forTime.style.display = "none";
            conSel.style.display = "block";
        }
    },

    datestr: function(diff) {
        var dt = new Date(this.sd.getTime() + Math.round(diff * 86400) * 1000);
        return formatDate(dt);
    },
    reorg: function() {
        var rowlist = this.rowList();
        var utime = this.sd.getTime();
        for (var i = 0; i < rowlist.length; i++) {
            var row = rowlist[i];
            row.className = (i % 2) ? "odd" : "even";
            row.getElementsByClassName("diaplay-time")[0].innerHTML = formatDate(new Date(utime));
            var time = this.rowTime(row);
            utime += Math.round(time * 86400) * 1000;
        }
    },
    chartdata: function() {
        var rowlist = this.rowList();
        if (rowlist.length == 0) return [];

        var utime = this.sd.getTime();
        var row = rowlist[0];
        var start = this.rowTemp(row);

        var list = [];
        list.push([new Date(utime), start]);

        for (var i = 0; i < rowlist.length; i++) {
            var row = rowlist[i];
            var temp;
            if (row.type == "r") {
                temp = this.rowTemp(rowlist[i + 1]);
            } else {
                temp = this.rowTemp(row);
            }
            utime += Math.round(this.rowTime(row) * 86400) * 1000;
            list.push([new Date(utime), temp]);
        }
        return list;
    },
    addRow: function() {
        var tb = document.getElementById("profile_t").getElementsByTagName("tbody")[0];
        var rowlist = tb.getElementsByTagName("tr");

        if (rowlist.length >= MAX_STEP) {
            alert(" Too many steps!");
            return;
        }
        var stage;

        if (rowlist.length == 0) {
            var init = (this.tempUnit == 'C') ? 20 : 68;
            stage = {
                c: 't',
                t: init,
                d: 1,
                g: 1.01
            };
        } else {
            var lastRow = rowlist[rowlist.length - 1];

            var tr = this.row.cloneNode(true);
            this.initrow(tr, {
                c: "r",
                d: 1
            });
            tb.appendChild(tr);
            stage = {
                c: 't',
                t: this.rowTemp(lastRow),
                d: 1,
                g: ""
            };
        }

        var tr = this.row.cloneNode(true);
        this.initrow(tr, stage);
        tb.appendChild(tr);

        this.reorg();
        this.markdirty(true);
        ControlChart.update(this.chartdata(), this.tempUnit);
    },
    delRow: function() {
        // delete last row
        var list = this.rowList();
        if (list.length == 0) return;
        var last = list[list.length - 1];

        if (list.length > 1) {
            var lr = list[list.length - 2];
            lr.parentNode.removeChild(lr);
        }

        last.parentNode.removeChild(last);

        this.markdirty(true);
        ControlChart.update(this.chartdata(), this.tempUnit);
    },
    rowTemp: function(row) {
        return parseFloat(row.getElementsByClassName("stage-temp")[0].innerHTML);
    },
    rowCondition: function(row) {
        return row.getElementsByClassName("condition")[0].value;
    },
    rowTime: function(row) {
        return parseFloat(row.getElementsByClassName("stage-time")[0].innerHTML);
    },
    rowSg: function(row) {
        return row.getElementsByClassName("stage-sg")[0].saved;
    },
    rowSt: function(row) {
        var data = row.getElementsByClassName("stage-stabletime")[0].innerHTML;
        if (typeof data != "string") return data;
        var matches = data.match(/^\s*(\d+)@(\d+)\s*$/);
        if (matches) {
            return parseInt(matches[2]);
        } else {
            return parseInt(data);
        }
    },
    rowStsg: function(row) {
        var data = row.getElementsByClassName("stage-stabletime")[0].innerHTML;
        if (typeof data != "string") return false;
        var matches = data.match(/^\s*(\d+)@(\d+)\s*$/);
        if (matches) {
            return parseInt(matches[1]);
        } else {
            return false;
        }
    },
    renderRows: function(g) {
        if (typeof g.length == "undefined")
            console.log("error!");
        var e = document.getElementById("profile_t").getElementsByTagName("tbody")[0];
        for (var f = 0; f < g.length; f++) {
            var c = this.row.cloneNode(true);
            this.initrow(c, g[f]);
            e.appendChild(c)
        }
        this.reorg()
    },

    initable: function(c, e) {
        this.setStartDate(e);
        if (!this.row) {
            var b = document.getElementById("profile_t").getElementsByTagName("tbody")[0];
            this.row = b.getElementsByTagName("tr")[0];
            b.removeChild(this.row);
        } else {
            this.clear();
        }
        this.renderRows(c)
    },
    clear: function() {
        var rl = this.rowList();

        var count = rl.length;
        for (var i = rl.length - 1; i >= 0; i--) {
            var tr = rl[i];
            tr.parentNode.removeChild(tr);
        }
        this.markdirty(true);
    },
    getProfile: function() {
        var rl = this.rowList();
        var lastdate = 0;
        var temps = [];
        for (var i = 0; i < rl.length; i++) {
            var tr = rl[i];
            var day = this.rowTime(tr);
            if (isNaN(day)) return false;

            if (tr.type == "r") {
                temps.push({
                    c: "r",
                    d: day
                });
            } else {
                var temp = this.rowTemp(tr);
                if (isNaN(temp)) return false;
                if (temp > BrewPiSetting.maxDegree || temp < BrewPiSetting.minDegree) return false;

                /*
                   <option value="t">Time</option>
                   <option value="g">SG</option>
                   <option value="s">Stable</option>
                   <option value="a">Time & SG</option>
                   <option value="o">Time OR SG</option>
                   <option value="u">Time OR Stable</option>
                   <option value="v">Time & Stable</option>
                    <option value="b">SG OR Stable</option>
                    <option value="x">SG & Stable</option>
                    <option value="w">ALL</option>
                    <option value="e">Either</option>
                */
                var condition = this.rowCondition(tr);
                var stage = {
                    c: condition,
                    d: day,
                    t: temp
                };

                var useSg = "gaobxwe";
                var gv = this.rowSg(tr);

                if (useSg.indexOf(condition) >= 0) {
                    if (gv == "") return false;
                    stage.g = gv;
                }
                var useStableTime = "suvbxwe";
                var stv = this.rowSt(tr);
                if (useStableTime.indexOf(condition) >= 0) {
                    if (isNaN(stv)) return false;
                    stage.s = stv;
                    var x = this.rowStsg(tr);
                    if (x) stage.x = x;
                }

                temps.push(stage);

            }
        }
        var s = this.sd.toISOString();
        var ret = {
            s: s,
            v: 2,
            u: this.tempUnit,
            t: temps
        };
        //console.log(ret);
        return ret;
    },
    loadProfile: function(a) {
        this.sd = new Date(a.s);
        this.tempUnit = a.u;
        this.clear();
        this.renderRows(a.t);
        ControlChart.update(this.chartdata(), this.tempUnit)
    },
    initProfile: function(p) {
        if (typeof p != "undefined") {
            // start date
            var sd = new Date(p.s);
            this.tempUnit = p.u;
            profileEditor.initable(p.t, sd);
        } else {
            profileEditor.initable([], new Date());
        }
    },
    setTempUnit: function(u) {
        if (u == this.tempUnit) return;
        this.tempUnit = u;
        var rl = this.rowList();
        for (var i = 0; i < rl.length; i++) {
            var tcell = rl[i].querySelector('td.stage-temp');
            var temp = parseFloat(tcell.innerHTML);
            if (!isNaN(temp)) tcell.innerHTML = (u == 'C') ? F2C(temp) : C2F(temp);
        }
    }
};

/* end of profile.js */
/* PL: profle list */
var PL = {
    pl_path: "P",
    url_list: "/list",
    url_save: "/fputs",
    url_del: "/rm",
    url_load: "pl.php?ld=",
    div: "#profile-list-pane",
    shown: false,
    initialized: false,
    plist: [],
    path: function(a) {
        return "/" + this.pl_path + "/" + a
    },
    depath: function(a) {
        return a.substring(this.pl_path.length + 1)
    },
    rm: function(e) {
        var f = this;
        var c = "path=" + f.path(f.plist[e]);
        s_ajax({
            url: f.url_del,
            m: "DELETE",
            data: c,
            success: function(a) {
                f.plist.splice(e, 1);
                f.list(f.plist)
            },
            fail: function(a) {
                alert("failed:" + a);
            }
        })
    },
    load: function(e) {
        var f = this;
        var c = f.path(f.plist[e]);
        s_ajax({
            url: c,
            m: "GET",
            success: function(b) {
                var a = JSON.parse(b);
                profileEditor.loadProfile(a);
            },
            fail: function(a) {
                //alert("failed:" + a);
            }
        })
    },
    list: function(i) {
        var a = this;
        var h = Q(a.div).querySelector(".profile-list");
        var lis = h.querySelectorAll("li");
        for (var i = 0; i < lis.length; i++) {
            h.removeChild(lis[i]);
        }
        var b = a.row;
        a.plist.forEach(function(f, g) {
            var c = b.cloneNode(true);
            c.querySelector(".profile-name").innerHTML = f;
            c.querySelector(".profile-name").onclick = function(j) {
                j.preventDefault();
                a.load(g);
                return false
            };
            c.querySelector(".rmbutton").onclick = function() {
                a.rm(g)
            };
            h.appendChild(c)
        })
    },
    append: function(b) {
        if (!this.initialized) {
            return
        }
        this.plist.push(b);
        this.list(this.plist)
    },
    init: function() {
        var a = this;
        a.initialized = true;
        a.row = Q(a.div).querySelector("li");
        a.row.parentNode.removeChild(a.row);
        s_ajax({
            url: a.url_list,
            m: "POST",
            data: "dir=" + a.path(""),
            success: function(c) {
                a.plist = [];
                var b = JSON.parse(c);
                b.forEach(function(e) {
                    if (e.type == "file") {
                        a.plist.push(a.depath(e.name))
                    }
                });
                a.list(a.plist)
            },
            fail: function(b) {
                alert("failed:" + b);
            }
        })
    },
    toggle: function() {
        if (!this.initialized) {
            this.init()
        }
        this.shown = !this.shown;
        if (this.shown) {
            Q(this.div).style.display = "block";
        } else {
            Q(this.div).style.display = "none";
        }
    },
    saveas: function() {
        Q("#dlg_saveas").style.display = "block"
    },
    cancelSave: function() {
        Q("#dlg_saveas").style.display = "none"
    },
    doSave: function() {
        var e = Q("#dlg_saveas input").value;
        if (e == "") {
            return
        }
        if (e.match(/[\W]/g)) {
            return
        }
        var g = profileEditor.getProfile();
        if (g === false) {
            alert("Invalid value. Check again");
            return
        }
        var f = this;
        var c = "path=" + f.path(e) + "&content=" + encodeURIComponent(JSON.stringify(g));
        var f = this;
        s_ajax({
            url: f.url_save,
            m: "POST",
            data: c,
            success: function(a) {
                f.append(e);
                f.cancelSave()
            },
            fail: function(a) {
                alert("failed:" + a);
            }
        })
    }
};
/* end of PL*/
var BrewPiSetting = {
    valid: false,
    maxDegree: 30,
    minDegree: 0,
    tempUnit: 'C'
};


var ControlChart = {
    unit: "C",
    init: function(div, data, unit) {
        var t = this;
        t.data = data;
        t.unit = unit;

        var dateFormatter = function(v) {
            d = new Date(v);
            return d.shortLocalizedString();
        };
        var shortDateFormatter = function(v) {
            d = new Date(v);
            var y = d.getYear() + 1900;
            var re = new RegExp('[^\d]?' + y + '[^\d]?');
            var n = d.toLocaleDateString();
            return n.replace(re, "");
        };

        var temperatureFormatter = function(v) {
            return v.toFixed(1) + "&deg;" + t.unit;
        };

        t.chart = new Dygraph(
            document.getElementById(div), t.data, {
                colors: ['rgb(89, 184, 255)'],
                axisLabelFontSize: 12,
                gridLineColor: '#ccc',
                gridLineWidth: '0.1px',
                labels: ["Time", "Temperature"],
                labelsDiv: document.getElementById(div + "-label"),
                legend: 'always',
                labelsDivStyles: {
                    'textAlign': 'right'
                },
                strokeWidth: 1,
                //        xValueParser: function(x) { return profileTable.parseDate(x); },
                //        underlayCallback: updateCurrentDateLine,
                //        "Temperature" : {},
                axes: {
                    y: {
                        valueFormatter: temperatureFormatter,
                        pixelsPerLabel: 20,
                        axisLabelWidth: 35
                    },
                    //            x : { axisLabelFormatter:dateFormatter, valueFormatter: dateFormatter, pixelsPerLabel: 30, axisLabelWidth:40 }
                    x: {
                        axisLabelFormatter: shortDateFormatter,
                        valueFormatter: dateFormatter,
                        pixelsPerLabel: 30,
                        axisLabelWidth: 40
                    }

                },
                highlightCircleSize: 2,
                highlightSeriesOpts: {
                    strokeWidth: 1.5,
                    strokeBorderWidth: 1,
                    highlightCircleSize: 5
                },

            }
        );
    },
    update: function(data, unit) {
        if (data.length == 0) return;
        this.data = data;
        this.unit = unit;
        this.chart.updateOptions({
            'file': this.data
        });
    }
};


var modekeeper = {
    initiated: false,
    modes: ["profile", "beer", "fridge", "off"],
    cmode: 0,
    dselect: function(m) {
        var d = document.getElementById(m + "-m");
        var nc = document.getElementById(m + "-m").className.replace(/\snav-selected/, '');
        d.className = nc;

        document.getElementById(m + "-s").style.display = "none";
    },
    select: function(m) {
        document.getElementById(m + "-m").className += ' nav-selected';
        document.getElementById(m + "-s").style.display = "block";
    },
    init: function() {
        var me = this;
        if (me.initiated) return;
        me.initiated = true;
        for (var i = 0; i < 4; i++) {
            var m = me.modes[i];
            document.getElementById(m + "-s").style.display = "none";
            document.getElementById(m + "-m").onclick = function() {
                var tm = this.id.replace(/-m/, '');
                me.dselect(me.cmode);
                me.select(tm);
                me.cmode = tm;
                return false;
            };
        }
        me.cmode = "profile";
        me.select(me.cmode);
    },
    apply: function() {
        if (!BrewPiSetting.valid) {
            alert("Not connected to controller.");
            //		return;
        }
        if ((this.cmode == "beer") || (this.cmode == "fridge")) {
            var v = document.getElementById(this.cmode + "-t").value;
            if (v == '' || isNaN(v) || (v > BrewPiSetting.maxDegree || v < BrewPiSetting.minDegree)) {
                alert("Invalid Temperature:" + v);
                return;
            }
            if (this.cmode == "beer") {
                //console.log("j{mode:b, beerSet:" + v+ "}");
                BWF.send("j{mode:b, beerSet:" + v + "}");
            } else {
                console.log("j{mode:f, fridgeSet:" + v + "}");
                BWF.send("j{mode:f, fridgeSet:" + v + "}");
            }
        } else if (this.cmode == "off") {
            //console.log("j{mode:o}");
            BWF.send("j{mode:o}");
        } else {
            // should save first.
            if (profileEditor.dirty) {
                alert("save the profile first before apply");
                return;
            }
            //console.log("j{mode:p}");
            document.getElementById('dlg_beerprofilereminder').style.display = "block";
            document.getElementById('dlg_beerprofilereminder').querySelector("button.ok").onclick = function() {
                document.getElementById('dlg_beerprofilereminder').style.display = "none";
                var gravity = parseFloat(Q("#dlg_beerprofilereminder input").value);
                if (typeof updateOriginGravity == "function") updateOriginGravity(gravity);
                var data = {
                    name: "webjs",
                    og: 1,
                    gravity: gravity
                };
                s_ajax({
                    url: "gravity",
                    m: "POST",
                    mime: "application/json",
                    data: JSON.stringify(data),
                    success: function(d) {
                        BWF.send("j{mode:p}");
                    },
                    fail: function(d) {
                        alert("failed:" + d);
                    }
                });
            };
            document.getElementById('dlg_beerprofilereminder').querySelector("button.oknog").onclick = function() {
                document.getElementById('dlg_beerprofilereminder').style.display = "none";
                BWF.send("j{mode:p}");
            };
            document.getElementById('dlg_beerprofilereminder').querySelector("button.cancel").onclick = function() {
                document.getElementById('dlg_beerprofilereminder').style.display = "none";
            };
        }
    }
};

function saveprofile() {
    //console.log("save");
    var r = profileEditor.getProfile();
    if (r === false) {
        alert("Invalid value. Check again");
        return;
    }
    var json = JSON.stringify(r);
    console.log("result=" + json);

    s_ajax({
        url: BPURL,
        m: "POST",
        mime: "application/x-www-form-urlencoded",
        data: "data=" + encodeURIComponent(json),
        success: function(d) {
            profileEditor.markdirty(false);
            alert("Done")
        },
        fail: function(d) {
            alert("failed to save.");
        }
    });
}

function updateTempUnit(u) {
    var Us = document.getElementsByClassName("t_unit");
    for (var i = 0; i < Us.length; i++) {
        Us[i].innerHTML = u;
    }
}

function ccparameter(s) {
    var setting = {
        valid: true,
        minDegree: s.tempSetMin,
        maxDegree: s.tempSetMax,
        tempUnit: s.tempFormat
    };
    if (setting.tempUnit != BrewPiSetting.tempUnit) {
        updateTempUnit(setting.tempUnit);
        profileEditor.setTempUnit(setting.tempUnit);
    }
    BrewPiSetting = setting;
}

function rcvBeerProfile(p) {
    closeDlgLoading();
    updateTempUnit(p.u); // using profile temp before we get from controller
    BrewPiSetting.tempUnit = p.u;
    profileEditor.initProfile(p);
    ControlChart.init("tc_chart", profileEditor.chartdata(), p.u);
}

function initctrl_C(next) {
    modekeeper.init();
    Capper.init();
    modekeeper.init();
    openDlgLoading();
}

function communicationError() {
    var div = Q('.error');
    if (div) {
        div.innerHTML = "Failed to connect to server.";
        div.style.display = "block";
    }
}

function initctrl() {
    getActiveNavItem();
    Capper.init();
    modekeeper.init();
    PTC.init(Q("#ptc-control"));
    openDlgLoading();

    BWF.init({
        onconnect: function() {
            BWF.send("c");
        },
        error: function(e) {
            //console.log("error");
            closeDlgLoading();
            communicationError();
        },
        handlers: {
            A: function(c) {
                if (typeof c["nn"] != "undefined") {
                    Q("#hostname").innerHTML = c["nn"];
                }
                if (typeof c["ver"] != "undefined") {
                    if (JSVERSION != c["ver"]) alert("Version Mismatched!. Reload the page.");
                    Q("#verinfo").innerHTML = "v" + c["ver"];
                }
                if (typeof c["cap"] != "undefined")
                    Capper.status(c["cap"]);
                if (typeof c["ptcs"] != "undefined")
                    PTC.config(c.ptcs);
            },
            C: function(c) { ccparameter(c); },
            B: rcvBeerProfile
        }
    });
}
</script>
    <script>
    var T_CHART_REQUEST = 12000;
    var T_CHART_RETRYTO = 6000;
    var T_CHART_ZERODATA = 10000;
    var T_CHART_REFRESH = 2500;
    var T_CHART_RETRY = 10000;
    var T_LOAD_CHART = 150;
    var T_BWF_RECONNECT = 10000;
    var T_BWF_LCD = 10000;
    var BChart = {
        offset: 0,
        url: 'chart.php',
        toggle: function(line) {
            this.chart.toggleLine(line);
        },
        updateFormula: function() {
            var coeff = this.chart.coefficients;
            var npt = (this.chart.npt << 24) | (this.chart.cal_igmask & 0xFFFFFF);
            var changed = true;
            if (typeof window.npt != "undefined" && window.npt == npt) {
                changed = false;
            }
            if (!changed) return;
            var url = "coeff?" + "a0=" + coeff[0].toFixed(9) +
                "&a1=" + coeff[1].toFixed(9) + "&a2=" + coeff[2].toFixed(9) +
                "&a3=" + coeff[3].toFixed(9) + "&pt=" + npt;
            s_ajax({
                url: url,
                m: "GET",
                success: function(d) { window.npt = npt; },
                fail: function(d) {
                    alert("Failed to update formula." + d);
                }
            });
        },
        reprocesData: function() {
            // recalcualte data
            // re process data to get correct calibration points
            var t = this;
            for (var i = 0; i < t.bdata.length; i++)
                t.chart.process(t.bdata[i]);
        },
        updateChartResult: function() {
            var t = this;
            if (t.chart.sg && !isNaN(t.chart.sg)) {
                updateGravity(t.chart.sg);
                t.chart.sg = NaN;
                checkfgstate();
            }
            t.chart.updateChart();
        },
        setIgnoredMask: function(m) {
            var t = this;
            if (t.chart.cal_igmask == m) return;

            t.chart.calculateSG = false;
            t.reprocesData();
            // the data will be updated by the "data"
            t.chart.cal_igmask = m;
            t.chart.getFormula();

            t.reprocesData();

            t.updateChartResult();
            // the data will be updated by the "data",again
            t.chart.cal_igmask = m;
            t.updateFormula();
        },
        reqdata: function() {
            var t = this;
            var PD = 'offset=' + t.offset;

            if (typeof t.startOff != "undefined" && t.startOff !== null)
                PD = PD + "&index=" + t.startOff;
            var xhr = new XMLHttpRequest();
            xhr.open('GET', t.url + '?' + PD);
            //	xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            //	xhr.setRequestHeader("Content-length", PD.length);
            xhr.timeout = T_CHART_REQUEST;
            xhr.responseType = 'arraybuffer';
            xhr.onload = function(e) {
                if (this.status == 404) {
                    console.log(" Error getting log data");
                    return;
                }
                // response is unsigned 8 bit integer
                var data = new Uint8Array(this.response);
                // backup data 
                if (t.offset) t.bdata.push(data);
                else t.bdata = [data];

                if (data.length == 0) {
                    //console.log("zero content");
                    if (t.timer) clearInterval(t.timer);
                    t.timer = null;
                    setTimeout(function() {
                        t.reqdata();
                    }, T_CHART_ZERODATA);
                    return;
                }
                var res = t.chart.process(data);
                if (res.nc) {
                    t.offset = data.length;
                    t.startOff = xhr.getResponseHeader("LogOffset");
                    //t.getLogName();
                    //console.log("new chart, offset="+t.startOff);
                    if (t.chart.calibrating) {
                        t.chart.getFormula();
                        //  do it again
                        t.chart.process(data);
                        if (t.chart.calculateSG) {
                            Q("#formula-btn").style.display = "block";
                            // update formula
                            t.updateFormula();
                        }
                    }
                } else {
                    t.offset += data.length;
                    if (t.chart.calibrating && res.sg) {
                        // new calibration data available. 
                        //force to reload and re-process the data
                        console.log("New SG availbe. reprocess");
                        t.chart.calculateSG = false;
                        t.reprocesData();
                        // the data will be updated by the "data"
                        t.chart.getFormula(); // derive the formula
                        // this time, the gravity is calculated.
                        t.reprocesData();
                        t.updateChartResult();
                        t.updateFormula();
                        return;
                    }
                }

                t.chart.updateChart();

                if (!isNaN(t.chart.og)) {
                    updateOriginGravity(t.chart.og);
                    t.chart.og = NaN;
                }
                if (t.chart.sg && !isNaN(t.chart.sg)) {
                    updateGravity(t.chart.sg);
                    t.chart.sg = NaN;
                    checkfgstate();
                }
                if (t.timer == null) t.settimer();
            };
            xhr.ontimeout = function(e) {
                console.error("Timeout!" + (new Date()));
                if (t.timer == null) setTimeout(function() {
                    t.reqdata();
                }, T_CHART_RETRYTO);
            };
            xhr.onerror = function() {
                console.log("Error getting data");
                if (t.timer == null) setTimeout(function() {
                    t.reqdata();
                }, T_CHART_RETRY);
            };
            //console.log(PD);
            xhr.send();
        },
        settimer: function() {
            var t = this;
            //console.log("start timer at "+ t.chart.interval);
            t.timer = setInterval(function() {
                t.reqdata();
            }, t.chart.interval * 1000);
        },
        init: function(id, y1, y2) {
            this.chart = new BrewChart(id);
            this.chart.setLabels(y1, y2);
        },
        timer: null,
        start: function() {
            if (this.running) return;
            this.running = true;
            this.offset = 0;
            this.reqdata();
        },
        reqnow: function() {
                var t = this;
                if (t.timer) clearInterval(t.timer);
                t.timer = null;
                t.reqdata();
            }
            /*
            , 
            getLogName: function() {
                s_ajax({
                    url: "loglist.php",
                    m: "GET",
                    success: function(d) {
                        var r = JSON.parse(d);
                        if (r.rec) {
                            Q("#recording").innerHTML = r.log;
                        } else {
                            Q("#recording").innerHTML = "";
                        }
                    },
                    fail: function(d) {
                        console.log("get logname fail");
                    }
                });
            }*/
    };
    /* LCD information */

    function parseStatusLine(line) {
        var status = {};
        var i = 0;
        var statePatterns = [
            /Idling\s+for\s+(\S+)\s*$/i,
            /control\s+OFF/i,
            /Door\s+Open/i,
            /Heating\s+for\s+(\S+)\s*$/i,
            /Cooling\s+for\s+(\S+)\s*$/i,
            /Wait\s+to\s+Cool\s+(\S+)\s*$/i,
            /Wait\s+to\s+Heat\s+(\S+)\s*$/i,
            /Waiting\s+for\s+Peak/i,
            /Cool\s+Time\s+left\s+(\S+)\s*$/i,
            /Heat\s+Time\s+left\s+(\S+)\s*$/i
        ];
        status.ControlStateSince = "";
        for (i = 0; i < statePatterns.length; i++) {
            var match = statePatterns[i].exec(line);
            if (match) {
                if (typeof match[1] !== "undefined") status.ControlStateSince = match[1];
                break;
            }
        }
        status.ControlState = i;
        status.StatusLine = line;
        return status;
    }


    function renderLcdText(info) {
        var div = Q(".error");
        if (div) div.style.display = "none";

        function T(temp) {
            if (temp < -10000) return "--.-";
            return (temp / 100).toFixed(1) + "&deg;" + info.tu;
        }
        var status = parseStatusLine(info.sl);
        status.ControlMode = info.md;
        status.unit = info.tu;
        status.BeerTemp = T(info.bt);
        status.BeerSet = T(info.bs);
        status.FridgeTemp = T(info.ft);
        status.FridgeSet = T(info.fs);
        status.RoomTemp = T(info.rt);

        var ModeString = {
            o: "OFF",
            b: "Beer Constant",
            f: "Fridge Const",
            p: "Beer Profile",
            i: "Invalid"
        };
        var StateText = [
            "Idling for {time}",
            "Temp. Control Off",
            "Door Open",
            "Heating for {time}",
            "Cooling for {time}",
            "Waiting to Cool {time}",
            "Waiting to Heat {time}",
            "Waiting for Peak",
            "Cool Time left {time}",
            "Heat Time left {time}",
            "Invalid State"
        ];

        function genStateText(state, duration) {
            if (typeof duration == "undefined") return StateText[state];

            var match;
            var timestr = "";
            if (match = /(\d+)h(\d\d)m(\d\d)/.exec(duration)) {
                timestr = "{HH}h{MM}m{SS}".replace("{SS}", match[3]).replace("{MM}", match[2]).replace("{HH}", match[1]);
            } else if (match = /(\d+)m(\d\d)/.exec(duration)) {
                // short
                timestr = "{MM}m{SS}".replace("{SS}", match[2]).replace("{MM}", match[1]);
            }
            return StateText[state].replace("{time}", timestr);
        }

        Object.keys(status).map(function(key, i) {
            var div = Q("#lcd" + key);
            if (div) {
                if (key == "ControlMode") div.innerHTML = ModeString[status[key]];
                else if (key == "ControlState") div.innerHTML = genStateText(status[key], status.ControlStateSince);
                else div.innerHTML = status[key];
            }
        });
        // keep the info for other usage
        if (typeof status["unit"] != "undefined") window.tempUnit = status.unit;
        if (typeof status["BeerTemp"] != "undefined") {
            var tempRE = /([\d\.]+)/;
            var temp = tempRE.exec(status.BeerTemp);
            if (temp.length > 0) window.beerTemp = temp[0];
        }
    }

    var roomOfridge = false;

    function simLcd(info) {

        var ModeString = {
            o: "Off",
            b: "Beer Const.",
            f: "Fridge Const.",
            p: "Beer Profile",
            i: "Invalid"
        };

        function showTemp(tp) {
            // always takes 5 chars
            if (tp < -10000) return " --.-";
            var text = (tp / 100.0).toFixed(1);
            var spaces = "";
            var i = text.length;
            for (; i < 5; i++) spaces += " ";
            return spaces + text;
        }

        var lines = [];
        lines[0] = "Mode   " + ModeString[info.md];
        lines[1] = "Beer  " + showTemp(info.bt) + " " + showTemp(info.bs) + " &deg;" + info.tu;
        if (info.rt > -10000 && roomOfridge)
            lines[2] = "Room  " + showTemp(info.rt) + " " + showTemp(-20000) + " &deg;" + info.tu;
        else
            lines[2] = "Fridge" + showTemp(info.ft) + " " + showTemp(info.fs) + " &deg;" + info.tu;
        roomOfridge = !roomOfridge;
        lines[3] = info.sl;
        return lines;
    }

    function displayLcdText(lines) {
        for (var i = 0; i < 4; i++) {
            var d = document.getElementById("lcd-line-" + i);
            if (d) d.innerHTML = lines[i];
        }
    }

    function displayLcd(info) {
        // classic interface
        window.tempUnit = info.tu;
        displayLcdText(simLcd(info));
        // new interface
        renderLcdText(info);
    }

    function hideErrorMsgs() {
        var msgs = document.querySelectorAll(".errormsg");
        for (var i = 0; i < msgs.length; i++)
            msgs[i].style.display = "none";
    }

    function communicationError() {
        var div = Q('.error');
        if (div) {
            hideErrorMsgs();
            Q('#error_connect').style.display = "block";
            div.style.display = "block";
        } else displayLcdText(["Failed to", "connect to", "Server", ""]);
    }

    function controllerError() {
        var div = Q('.error');
        if (div) {
            hideErrorMsgs();
            Q('#error_noupdate').style.display = "block";
            div.style.display = "block";
        } else displayLcdText(["Controller not", "updating data", "...", ""]);
    }

    function checkTime(time, tzoff) {
        var d = new Date();
        var tmoff = 0 - d.getTimezoneOffset() * 60;
        var tm = Math.round(d.getTime() / 1000);
        if (tzoff != tmoff || Math.abs(tm - time) > 1800) {
            // update time & timezone
            s_ajax({
                url: "time",
                m: "POST",
                mime: "application/x-www-form-urlencoded",
                data: "time=" + tm + "&off=" + tmoff,
                success: function() {}
            });

        }
    }

    function gravityDevice(msg) {

        //if (typeof msg["name"] == "undefined") return;
        if (typeof msg["plato"] != "undefined") {
            window.plato = msg.plato;
            if (window.plato) showPlatoUnit();
        }
        if (typeof msg["fpt"] != "undefined") {
            window.npt = msg["fpt"];
        }
        // before iSpindel report to BPL, the name file is "unknown"
        if (typeof msg["name"] == "undefined") return
            //The first report will be "unknown" if (msg.name.startsWith("iSpindel")) {
            // iSpindel
        if (typeof msg["lu"] == "undefined") {
            console.log("iSpindel:" + JSON.stringify(msg));
            return;
        }
        if (msg.name.startsWith("iSpindel"))
            if (typeof window.iSpindel == "undefined") {
                window.iSpindel = true;
                if (Q("#iSpindel-pane"))
                    Q("#iSpindel-pane").style.display = "block";
            }
        var ndiv = Q("#iSpindel-name");
        if (ndiv) ndiv.innerHTML = msg.name;

        if (typeof msg["battery"] != "undefined" && Q("#iSpindel-battery"))
            Q("#iSpindel-battery").innerHTML = msg.battery;

        var lu;
        if (typeof msg["lu"] != "undefined")
            lu = new Date(msg.lu * 1000);
        else
            lu = new Date();
        if (Q("#iSpindel-last"))
            Q("#iSpindel-last").innerHTML = lu.shortLocalizedString();

        if (!BChart.chart.calibrating && typeof msg["sg"] != "undefined" &&
            msg.sg > 0)
            updateGravity(msg.sg);

        if (typeof msg["angle"] != "undefined") {
            if (Q("#iSpindel-tilt"))
                Q("#iSpindel-tilt").innerHTML = "" + msg["angle"];
        }
        if (typeof msg["rssi"] != "undefined"){
            if(Q("#ispindel-rssi")){
                Q("#ispindel-rssi").classList.remove("no-display");
                wifibar("#ispindel-rssi",msg.rssi);
            }
        }
        //}
        if (typeof msg["lpf"] != "undefined")
            GravityFilter.setBeta(msg["lpf"]);

        if (typeof msg["stpt"] != "undefined")
            GravityTracker.setThreshold(msg["stpt"]);

        if (typeof msg["ctemp"] != "undefined")
            window.caltemp = msg["ctemp"];
    }


    function updateGravity(sg) {
        //if(typeof window.sg != "undefined") return;
        window.sg = sg;
        Q("#gravity-sg").innerHTML = window.plato ? sg.toFixed(1) : sg.toFixed(3);
        if (typeof window.og != "undefined") {
            Q("#gravity-att").innerHTML = window.plato ? BrewMath.attP(window.og, sg) : BrewMath.att(window.og, sg);
            Q("#gravity-abv").innerHTML = window.plato ? BrewMath.abvP(window.og, sg) : BrewMath.abv(window.og, sg);
        }
    }

    function updateOriginGravity(og) {
        if (typeof window.og != "undefined" && window.og == og) return;
        window.og = og;
        Q("#gravity-og").innerHTML = window.plato ? og.toFixed(1) : og.toFixed(3);
        if (typeof window.sg != "undefined")
            updateGravity(window.sg);
    }

    function showgravitydlg(msg) {
        Q('#dlg_addgravity .og').style.display = "none";
        Q('#dlg_addgravity .sg').style.display = "none";
        Q('#dlg_addgravity .' + msg).style.display = "block";
        Q('#dlg_addgravity').style.display = "block";
        // update temp.
        if (typeof window["tempUnit"] != "undefined") {
            window.celsius = false;
            var defaultTemp = 68;
            var re = /C$/;
            if (re.test(window.tempUnit)) {
                window.celsius = true;
                defaultTemp = 20;
            }
            Q("#dlg_addgravity .tempinput").value = defaultTemp;

            var tus = document.querySelectorAll("#dlg_addgravity .temp-unit");
            for (var i = 0; i < tus.length; i++)
                tus[i].innerHTML = window.tempUnit;
        } else window.celsius = true;
    }

    function dismissgravity() {
        Q('#dlg_addgravity').style.display = "none";
    }

    function inputsg_change() {
        var gravity = parseFloat(Q("#dlg_addgravity .sginput").value);
        var temp = parseFloat(Q("#dlg_addgravity .tempinput").value);
        if (isNaN(gravity) || isNaN(temp)) return;
        // if calibration info is avilable
        var caltemp = (typeof window.caltemp != "undefined") ? window.caltemp : 20;
        caltemp = window.celsius ? caltemp : C2F(caltemp);
        // calibration temperature always use celsius.
        Q("#sginput-hm-cal-temp").innerHTML = caltemp;
        if (window.plato) {
            var correctedSg = BrewMath.pTempCorrection(window.celsius, gravity, temp, caltemp);
            Q("#sginput-hmc").innerHTML = correctedSg.toFixed(2);

        } else {
            var correctedSg = BrewMath.tempCorrection(window.celsius, gravity, temp, caltemp);
            Q("#sginput-hmc").innerHTML = correctedSg.toFixed(3);
        }
        // if iSpindel info is available, or beer temp is available.
        if (typeof window.beerTemp != "undefined") {
            Q("#sginput-ispindel-temp").innerHTML = window.beerTemp;
            if (window.plato) {
                var sgc = BrewMath.pTempCorrection(window.celsius, gravity, temp, window.beerTemp);
                Q("#sginput-sg-ispindel").innerHTML = sgc.toFixed(2);
            } else {
                var sgc = BrewMath.tempCorrection(window.celsius, gravity, temp, window.beerTemp);
                Q("#sginput-sg-ispindel").innerHTML = sgc.toFixed(3);
            }
        }
    }

    function inputgravity() {
        var gravity = parseFloat(Q("#sginput-hmc").innerHTML);

        if (!window.plato && (gravity < 0.8 || gravity > 1.25)) return;

        dismissgravity();
        openDlgLoading();

        if (window.isog) updateOriginGravity(gravity);
        else updateGravity(gravity);

        var data = {
            name: "webjs",
            gravity: gravity
        };
        if (window.isog) data.og = 1;
        if (window.plato) data.plato = 1;
        s_ajax({
            url: "gravity",
            m: "POST",
            mime: "application/json",
            data: JSON.stringify(data),
            success: function(d) {
                closeDlgLoading();
                setTimeout(function() {
                    // request to 
                    if (BChart.chart.calibrating) BChart.reqnow();
                }, T_CHART_REFRESH);
            },
            fail: function(d) {
                alert("failed:" + d);
                closeDlgLoading();
            }
        });

    }

    function inputSG() {
        window.isog = false;
        showgravitydlg("sg");
    }

    function inputOG() {
        window.isog = true;
        showgravitydlg("og");
    }

    function wifibar(did,x){
        var strength = [-1000, -90, -80, -70, -67];
        var bar = 4;
        for (; bar >= 0; bar--) {
            if (strength[bar] < x) break;
        }
        var bars = Q(did).getElementsByClassName("rssi-bar");
        for (var i = 0; i < bars.length; i++) {
            bars[i].style.backgroundColor = (i < bar) ? window.rssiBarColor : "rgba(255,255,255,0.05)";
        }
        Q(did).title = (x > 0) ? "?" : Math.min(Math.max(2 * (x + 100), 0), 100);

    }

    function displayrssi(x) {
        Q("#rssi").title = (x > 0) ? "?" : Math.min(Math.max(2 * (x + 100), 0), 100);
        wifibar("#rssi",x);
        if (Q("#wifisignal"))
            Q("#wifisignal").innerHTML = (x > 0) ? "?" : Math.min(Math.max(2 * (x + 100), 0), 100);
    }

    function initRssi() {
        var rssi = Q("#rssi");
        window.rssiBarColor = window.getComputedStyle(Q('.rssi-bar1')).getPropertyValue('background-color');
        if (Q("#wifisignal")) {
            rssi.onmouseover = function() {
                Q("#wifisignal").style.display = "block";
            };
            rssi.onmouseout = function() {
                Q("#wifisignal").style.display = "none";
            };
        }
    }

    function ptcshow(msg) {
        if (typeof msg["ptc"] == "undefined" || typeof msg["pt"] == "undefined") return;
        var mode = msg.ptc;
        var time = msg.pt;

        function fortime(t) {
            var hour = Math.floor(t / 3600);
            var min = Math.floor((t - hour * 3600) / 60);
            var sec = t - hour * 3600 - min * 60;
            return ((hour) ? (hour + "H") : "") + ((hour + min) ? (min + "M") : "") + sec + "S";
        }
        var pane = Q("#ptc-pane");
        if (pane) {
            if (mode == "o") pane.style.display = "none";
            else {
                pane.style.display = "block";
            }
        } else return;
        var state = Q("#ptc-state");
        if (state) state.style.backgroundColor = (mode == "c") ? "lightgreen" : "gray";

        var textstateidle = Q("#ptc-state-idle");
        if (textstateidle) {
            var textstaterun = Q("#ptc-state-run");
            if (mode == "c") {
                textstateidle.style.display = "none";
                textstaterun.style.display = "block";
            } else {
                textstateidle.style.display = "block";
                textstaterun.style.display = "none";
            }
        }

        var tinfo = Q("#ptc-time");
        if (tinfo) tinfo.innerHTML = fortime(time);
        if (typeof msg["ptctp"] != "undefined") {
            var temp = Q("#ptc-temp");

            if (temp) temp.innerHTML = (msg.ptctp < -100) ? "NA" : ((msg.ptctp / 100) + "&deg;C");
        }
        if (typeof msg["ptclo"] != "undefined" && typeof msg["ptcup"] != "undefined") {
            var ts = Q("#ptc-set");
            if (ts) ts.innerHTML = (msg.ptclo / 100) + " ~ " + (msg.ptcup / 100) + "&deg;C";
        }
    }

    function showPlatoUnit() {
        var units = document.querySelectorAll(".platounit");
        for (var i = 0; i < units.length; i++) {
            units[i].style.display = "inline-block";
        }
    }

    function BPLMsg(c) {
        BWF.gotMsg = true;

        if (typeof c["rssi"] != "undefined") {
            displayrssi(c["rssi"]);
        }
        if (typeof c["sl"] != "undefined") {
            displayLcd(c);
        }
        if (typeof c["reload"] != "undefined") {
            console.log("Forced reload chart");
            BChart.reqnow();
            if (!Q("#recording").innerHTML || Q("#recording").innerHTML != c.log)
                window.npt = 0; // delete formula to force update to BPL.                
        }
        if (typeof c["nn"] != "undefined") {
            Q("#hostname").innerHTML = c["nn"];
            document.title = c.nn; // + document.title.replace("BrewPiLess", "");
        }
        if (typeof c["ver"] != "undefined") {
            if (JSVERSION != c["ver"]) alert("Version Mismatched!. Reload the page.");
            Q("#verinfo").innerHTML = "v" + c["ver"];
        }
        if (typeof c["tm"] != "undefined" && typeof c["off"] != "undefined") {
            checkTime(c.tm, c.off);
        }
        if (typeof c["log"] != "undefined") {
            Q("#recording").innerHTML = c.log;
        }
        if (typeof c["cap"] != "undefined")
            Capper.status(c["cap"]);
        if (typeof c["plato"] != "undefined") {
            window.plato = c["plato"];
            if (window.plato) showPlatoUnit();
        }

        if (typeof c["pm"] != "undefined" && typeof c["psi"] != "undefined") {
            if (c.pm != 0) {
                Q("#pressure-info-pane").style.display = "block";
                Q("#pressure-psi").innerHTML = c.psi;
            }
        }

        ptcshow(c);
    }

    function connBWF() {
        BWF.init({
            //            reconnect: false,
            onconnect: function() {
                BWF.send("c");
                if (window.lcdTimer) clearInterval(window.lcdTimer);
                window.lcdTimer = setInterval(function() {
                    if (!BWF.gotMsg) {
                        if (window.rcTimeout) {
                            // reconnect timer is running.
                            BWF.rcCount++;
                            console.log("rcTimeout failed.");
                            // let the reconnecting timer has more chances to do its job                         
                            if (BWF.rcCount < 3) return;
                            // restart reconect timer
                            clearTimer(window.rcTimeout);
                        }
                        // once connected.
                        //  no data for 5 seconds
                        controllerError();
                        window.rcTimeout = setTimeout(function() {
                            window.rcTimeout = null;
                            if (!BWF.gotMsg) BWF.reconnect(true);
                        }, T_BWF_RECONNECT);
                        BWF.rcCount = 0;
                        // setTimer might not be reliable. when the computer enter suspended state.
                        // keep this timer for saftey.
                        // clearInterval(window.lcdTimer);
                        //window.lcdTimer = null;
                        return;
                    }
                    //gotMsg==true, set flag and send
                    BWF.gotMsg = false;
                    //BWF.send("l");
                }, T_BWF_LCD);
            },
            error: function(e) {
                //console.log("error");
                // when connection establishment fails 
                // or connection broken
                communicationError();
                // do nothing, let BWF do the resconnection.
                //              setTimeout(function() {
                //                   if (!BWF.gotMsg) BWF.reconnect();
                //              }, 12000);
                closeDlgLoading();
            },
            handlers: {
                /*                L: function(lines) {
                                    BWF.gotMsg = true;
                                    processLcdText(lines);
                            },*/
                A: BPLMsg,
                G: function(c) {
                    gravityDevice(c);
                },
                // for control page. 
                C: function(c) { if (typeof ccparameter != "undefined") ccparameter(c); },
                B: function(c) { if (typeof rcvBeerProfile != "undefined") rcvBeerProfile(c); }
            }
        });
    }

    function init_classic() {
        window.plato = false;
        BChart.init("div_g", Q('#ylabel').innerHTML, Q('#y2label').innerHTML);
        initRssi();
        Capper.init();
        BWF.gotMsg = true;
        initctrl_C();
        connBWF();
        setTimeout(function() { BChart.start(); }, T_LOAD_CHART);
    }

    function init() {
        Q("#pressure-info-pane").style.display = "none";
        window.plato = false;
        BChart.init("div_g", Q('#ylabel').innerHTML, Q('#y2label').innerHTML);
        initRssi();
        Capper.init();
        BWF.gotMsg = true;
        connBWF();
        setTimeout(function() { BChart.start(); }, T_LOAD_CHART);
        getActiveNavItem();
    }
</script>
    <style>
        /* LCD display styling */
        
        .lcddisplay {
            width: 280px;
            height: 90px;
            float: left;
            margin: 5px;
            background: #000000;
            /* Old browsers */
            background: -moz-linear-gradient(top, #000000 2%, #2b2b2b 11%, #212121 54%, #212121 92%, #000000 100%);
            /* FF3.6+ */
            background: -webkit-gradient(linear, left top, left bottom, color-stop(2%, #000000), color-stop(11%, #2b2b2b), color-stop(54%, #212121), color-stop(92%, #212121), color-stop(100%, #000000));
            /* Chrome,Safari4+ */
            background: -webkit-linear-gradient(top, #000000 2%, #2b2b2b 11%, #212121 54%, #212121 92%, #000000 100%);
            /* Chrome10+,Safari5.1+ */
            background: -o-linear-gradient(top, #000000 2%, #2b2b2b 11%, #212121 54%, #212121 92%, #000000 100%);
            /* Opera11.10+ */
            background: -ms-linear-gradient(top, #000000 2%, #2b2b2b 11%, #212121 54%, #212121 92%, #000000 100%);
            /* IE10+ */
            filter: progid: DXImageTransform.Microsoft.gradient( startColorstr='#000000', endColorstr='#000000', GradientType=0);
            /* IE6-9 */
            background: linear-gradient(top, #000000 2%, #2b2b2b 11%, #212121 54%, #212121 92%, #000000 100%);
            /* W3C */
            -webkit-box-shadow: inset 1px 1px 5px #333333;
            -moz-box-shadow: inset 1px 1px 5px #333333;
            box-shadow: inset 1px 1px 5px #333333;
            border: 2px solid #333;
            -webkit-border-radius: 2px;
            -moz-border-radius: 2px;
            border-radius: 2px;
        }
        
        .lcddisplay .lcd-text {
            float: left;
            margin: 5px 16px;
        }
        
        .lcd-line {
            float: left;
            clear: left;
            font-size: 16px;
            font-weight: normal;
            font-style: normal;
            font-family: "Courier New", Courier, monospace;
            color: #FFFF00;
            white-space: pre;
        }
        
        .chart-legend-row .toggle {
            width: 8px;
            height: 8px;
            border-radius: 5px;
            float: left;
            margin: 2px 0 0 0;
            cursor: pointer;
            border: 1px solid;
        }
        
        .chart-legend {
            font-family: Lucida Grande, Lucida Sans, Arial, sans-serif;
            font-size: 11px;
            margin: 10px 0 0 0;
            border: solid 1px #777;
            border-radius: 5px;
            float: right;
            width: 155px;
        }
        
        .chart-legend-row {
            padding: 8px 5px 8px 5px;
        }
        
        .legend-label {
            float: left;
            padding: 0 5px 0 5px;
            cursor: pointer;
        }
        
        .legend-value {
            float: right;
        }
        
        .chart-legend-row.time {
            background-color: #ddeeff;
        }
        
        #div_lb {
            display: none;
        }
        
        #div_g {
            float: left;
            width: 800px;
            height: 390px;
        }
        
        #chart-container {
            width: 965px;
            height: 410px;
            padding: 5px 5px 5px 5px;
        }
        
        .hide {
            display: none;
        }
        
        .frame {
            border-radius: 5px;
            margin: 5px 5px 5px 5px;
            border: solid 1px #304d75;
            width: 975px;
        }
        
        #top-frame {
            height: 520px;
        }
        
        #bottom-frame {
            height: 380px;
        }
        
        #topbar {
            width: 965px;
            height: 108px;
            background-color: rgb(92, 156, 204);
            padding: 5px 5px 5px 5px;
        }
        
        #menu {
            float: right;
        }
        
        #banner {
            font-size: 18pt;
            float: left;
            color: white;
            /*            font-family: "Comic Sans MS", cursive, sans-serif;*/
            margin-top: 20px;
            margin-left: 20px;
        }
        
        #recording {
            color: lightblue;
            font-size: 18px;
            font-family: serif;
        }
        
        #top-frame button {
            float: right;
            width: 200px;
            margin-top: 3px;
        }
        /* control*/
        
        .navbar {
            margin: 0;
            padding: .2em .2em 0;
            border: 1px solid #4297d7;
            background: #5c9ccc;
            color: #ffffff;
            height: 4em;
            display: block;
            position: relative;
            width: 968px;
        }
        
        #set-mode-text {
            margin-left: 2px;
            float: left;
            margin: .2em;
        }
        
        .navitem {
            background: #dfeffc;
            font-weight: bold;
            color: #2e6e9e;
            margin: .2em .2em 0 0;
            padding: .5em;
            border-top-right-radius: 5px;
            border-top-left-radius: 5px;
        }
        
        .nav-selected {
            background: #ffffff;
            font-weight: bold;
            color: #e17009;
            margin: .2em .2em 0 0;
            padding: .5em .5em .75em .5em;
        }
        
        .navitems {
            display: block;
            margin-top: 2em;
        }
        
        #apply {
            background: #dfeffc;
            font-weight: bold;
            color: #2e6e9e;
            margin: .2em .1em 0 0;
            padding: .5em;
        }
        
        .tab-containter {
            margin: 0.5em;
            width: 965px;
        }
        
        .profileTable td,
        th {
            padding: 3px;
            text-align: center;
        }
        
        .profileTable tbody TR.odd {
            background: #f7f7f7;
        }
        
        .profileTable tbody TR.even {
            width: 100%;
        }
        
        .profileTable TH {
            border: 1px solid #4297d7;
            background: #5c9ccc;
            color: #ffffff;
            font-weight: bold;
        }
        
        table.profileTable {
            width: 100%;
        }
        
        #bottom-frame button {
            color: #1d5987;
            background: #dfeffc;
            font-weight: bold;
            border-radius: 6px;
            margin: 4px;
        }
        
        #addbutton {
            float: right;
            width: 120px;
        }
        
        #header {}
        
        #clearbtn {
            width: 18%;
        }
        
        #savebtn {
            width: 25%;
            float: right;
        }
        
        #delbtn {
            width: 18%;
        }
        
        .modal {
            display: none;
            /* Hidden by default */
            position: fixed;
            /* Stay in place */
            z-index: 100;
            /* Sit on top */
            padding-top: 20px;
            /* Location of the box */
            left: 0;
            top: 0;
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
            overflow: auto;
            /* Enable scroll if needed */
            background-color: rgb(0, 0, 0);
            /* Fallback color */
            background-color: rgba(0, 0, 0, 0.4);
            /* Black w/ opacity */
        }
        /* Modal Content */
        
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 10px;
            border: 1px solid #888;
            width: 340px;
            height: 220px;
            border-radius: 8px;
        }
        
        #dlg_addgravity button {
            float: right;
            width: 56px;
            margin-top: 2px;
        }
        
        .dialog-buttons {
            float: center;
        }
        
        #modekeeper-apply {
            margin-top: 0px;
        }
        
        #profile-edit {
            float: left;
            margin: 6px;
            width: 510px;
            position: relative;
        }
        
        #tc_chart {
            width: 430px;
            height: 280px;
            float: right;
            margin: 6px;
        }
        
        .info-pane table {
            width: 92px;
            float: right;
            border: 1px solid white;
            border-radius: 5px;
            margin-right: 4px;
            color: cyan;
            font-size: 12px;
        }
        
        .hidden-pane {
            display: none;
        }
        
        #profile-list-pane .modal-content {
            height: 360px;
            width: 240px;
            overflow: scroll;
        }
        
        #profile-list-pane {
            border-style: outset;
            border: solid 3px;
            overflow: auto;
        }
        
        #profile-list-pane li {
            white-space: nowrap;
            overflow: hidden;
        }
        
        #profile-list-pane .rmbutton {
            color: red;
        }
        
        #profile-list-pane a,
        #profile-list-pane u {
            text-decoration: none;
        }
        
        .small-led {
            width: 10px;
            height: 10px;
            border-radius: 6px;
            border: 0px;
        }
        
        #fgstate {
            margin: 4px 0 0 0;
            float: right;
        }
        
        #rssi {
            float: right;
            position: relative;
            margin: 0px 16px 0px 0px;
            height: 16px;
            width: 12px;
            display: inline-block;
        }
        
        #wifisignal {
            font-size: 12pt;
            color: black;
            font-family: Courier New, Courier, monospace;
            position: absolute;
            top: 2px;
            left: 2px;
            display: none;
        }
        
        .rssi-bar {
            position: absolute;
            bottom: 0;
            float: left;
            width: 4px;
            border-radius: 1px;
            background-color: #FFFFFF;
        }
        
        .rssi-bar1 {
            height: 4px;
            left: 0px;
        }
        
        .rssi-bar2 {
            height: 8px;
            left: 6px;
        }
        
        .rssi-bar3 {
            height: 12px;
            left: 12px;
        }
        
        .rssi-bar4 {
            height: 16px;
            left: 18px;
        }
        
        #verinfo {
            display: inline-block;
            font-size: 8pt;
            color: white;
        }
        /* iSpindel calibration */
        
        #pointlist th,
        #pointlist td,
        #pointlist tr,
        #pointlist {
            border: 1px solid;
            border-collapse: collapse;
        }
        
        #pointlist th {
            width: 52px;
            background-color: #ffff27;
        }
        
        #pointlist td {
            text-align: right;
        }
        
        #graph {
            width: 500px;
            height: 500px;
        }
        
        #formula-btn {
            font-style: italic;
            float: right;
            display: none;
        }
        
        #polynomialpane .modal-content {
            width: 800px;
            height: 600px;
            position: relative;
        }
        
        #xclose {
            position: absolute;
            color: red;
            background-color: lightgray;
            width: 20px;
            height: 20px;
            right: 0;
            text-align: center;
            cursor: pointer;
        }
        
        #gravity-sg,
        #gravity-og {
            cursor: pointer;
        }
        
        .platounit {
            display: none;
        }
    </style>
</head>

<body onload="init_classic()">
    <div style="display:none">
        <span id="ylabel">Temperature</span>
        <span id="y2label">Gravity</span>
    </div>

    <div class="frame" id="top-frame">
        <div id="topbar">
            <div id="lcd" class="lcddisplay"><span class="lcd-text">
             <span class="lcd-line" id="lcd-line-0"> Live LCD waiting</span>
                <span class="lcd-line" id="lcd-line-1"> for update from</span>
                <span class="lcd-line" id="lcd-line-2"> script...</span>
                <span class="lcd-line" id="lcd-line-3"> </span><p></p>
                <p>
            </p></span></div>
            <div id="banner">
                <div id="hostname">BrewPiLess</div>
                <div id="recording"></div>
            </div>
            <div id="menu">
                <div id="versionsignal">
                    <div id="verinfo">v2</div>
                    <div id="rssi">
                        <div class="rssi-bar rssi-bar1"></div>
                        <div class="rssi-bar rssi-bar2"></div>
                        <div class="rssi-bar rssi-bar3"></div>
                        <div class="rssi-bar rssi-bar4"></div>
                        <div id="wifisignal">?</div>
                    </div>
                </div>
                <button onclick="window.open('/log')">Data Logging</button>
                <br>
                <button onclick="window.open('/setup.htm')">Device Setup</button>
                <br>
                <button onclick="window.open('/config')">System Config</button>
                <br>
                <button onclick="window.open('/gdc')">Gravity Sensor</button>
            </div>
            <div id="gravity-pane" class="info-pane">
                <table>
                    <tr>
                        <th>
                            OG:
                        </th>
                        <td> <span id="gravity-og" onclick="inputOG()">--</span> <span class="platounit">&deg;P</span>
                        </td>
                    </tr>
                    <tr>
                        <th>
                            SG:
                        </th>
                        <td> <span id="gravity-sg" onclick="inputSG()">--</span> <span class="platounit">&deg;P</span>
                            <div id="fgstate" class="small-led"></div>
                        </td>
                    </tr>
                    <tr>
                        <th>
                            ATT:
                        </th>
                        <td> <span id="gravity-att"> --</span>%
                        </td>
                    </tr>
                    <tr>
                        <th>
                            ABV:
                        </th>
                        <td> <span id="gravity-abv"> --</span>%
                        </td>
                    </tr>

                </table>
            </div>

            <div id="iSpindel-pane" class="info-pane hidden-pane">
                <table>
                    <tr>
                        <th colspan="2"><span id="iSpindel-name"></span></th>
                    </tr>
                    <tr>
                        <th>
                            Battery:
                        </th>
                        <td> <span id="iSpindel-battery">--</span>
                        </td>
                    </tr>
                    <tr>
                        <th>
                            Tilt:
                        </th>
                        <td><span id="iSpindel-tilt"></span></td>
                    </tr>
                    <tr>
                        <td colspan="2" align="center">@<span id="iSpindel-last">--</span>
                        </td>
                    </tr>
                </table>
            </div>

            <div id="ptc-pane" class="info-pane hidden-pane">
                <table>
                    <tr>
                        <th>
                            PTC
                        </th>
                        <td>
                            <div id="ptc-state" class="small-led"></div>
                        </td>
                    </tr>
                    <tr>
                        <th>
                            TEMP
                        </th>
                        <td>
                            <div id="ptc-temp">11 &deg;C</div>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="2" align="center">
                            <span id="ptc-set"></span>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="2" align="center"><span id="ptc-time">100H59M32S</span></td>
                    </tr>
                </table>
            </div>

        </div>

        <div id="chart-container">
            <div id="div_g"></div>

            <div id="chart-legend" class="chart-legend">
                <div class="chart-legend-row time">
                    <div class="beer-chart-legend-time">
                        Date / Time
                    </div>
                </div>
                <div class="chart-legend-row beer-temp">
                    <div class="toggle beer-temp" onclick="BChart.toggle(BeerTempLine)"></div>
                    <div class="legend-label" onclick="BChart.toggle(BeerTempLine)">
                        Beer Temp
                    </div>
                    <div class="legend-value">--</div>
                    <br>
                </div>
                <div class="chart-legend-row beer-set">
                    <div class="toggle beer-set" onclick="BChart.toggle(BeerSetLine)"></div>
                    <div class="legend-label" onclick="BChart.toggle(BeerSetLine)">
                        Beer Set
                    </div>
                    <div class="legend-value">--</div>
                    <br>
                </div>
                <div class="chart-legend-row fridge-temp">
                    <div class="toggle fridge-temp" onclick="BChart.toggle(FridgeTempLine)"></div>
                    <div class="legend-label" onclick="BChart.toggle(FridgeTempLine)">
                        Fridge Temp
                    </div>
                    <div class="legend-value">--</div>
                    <br>
                </div>
                <div class="chart-legend-row fridge-set">
                    <div class="toggle fridge-set" onclick="BChart.toggle(FridgeSetLine)"></div>
                    <div class="legend-label" onclick="BChart.toggle(FridgeSetLine)">
                        Fridge Set
                    </div>
                    <div class="legend-value">--</div>
                    <br>
                </div>

                <div class="chart-legend-row room-temp">
                    <div class="toggle room-temp" onclick="BChart.toggle(RoomTempLine)"></div>
                    <div class="legend-label" onclick="BChart.toggle(RoomTempLine)">
                        Room Temp
                    </div>
                    <div class="legend-value">--</div>
                    <br>
                </div>
                <div class="chart-legend-row aux-temp">
                    <div class="toggle aux-temp" onclick="BChart.toggle(AuxTempLine)"></div>
                    <div class="legend-label" onclick="BChart.toggle(AuxTempLine)">
                        Aux Temp
                    </div>
                    <div class="legend-value">--</div>
                    <br>
                </div>
                <div class="chart-legend-row gravity">
                    <div class="toggle gravity" onclick="BChart.toggle(GravityLine)"></div>
                    <div class="legend-label" onclick="BChart.toggle(GravityLine)">
                        Gravity
                    </div>
                    <div class="legend-value">--</div>
                    <br>
                </div>
                <div class="chart-legend-row filtersg">
                    <div class="toggle filtersg" onclick="BChart.toggle(FilteredSgLine)"></div>
                    <div class="legend-label" onclick="BChart.toggle(FilteredSgLine)">
                        Filtered SG
                    </div>
                    <div class="legend-value">--</div>
                    <br>
                </div>

                <div class="chart-legend-row state">
                    <div class="beer-chart-state">
                        state
                    </div>
                    <br>
                </div>
                <div class="chart-legend-row" id="formula-btn" onclick="openpolynomialpane()">
                    <div class="legend-label">f</div>
                    <br>
                </div>
            </div>
        </div>
    </div>
    <div class="frame" id="bottom-frame">
        <div class="navbar" id="header">
            <div id="set-mode-text">
                Set temperature mode:
            </div>
            <div class="navitems">
                <span class="navitem" id="profile-m">Beer Profile</span>
                <span class="navitem" id="beer-m">Beer Const.</span>
                <span class="navitem" id="fridge-m">Fridge Const.</span>
                <span class="navitem" id="off-m">Off</span>
                <button id="modekeeper-apply" onclick="modekeeper.apply()">Apply</button>
            </div>
        </div>

        <div class="tab-containter">
            <div id="profile-s" class="detail">
                <div id="profile-edit">
                    <div>
                        <div><span>Start Date:</span><input type="text" size="16" id="startdate" onchange="profileEditor.startDayChange();">
                            <button id="setnow" onclick="profileEditor.startnow();">Now</button>
                            <button id="addbutton" onclick="profileEditor.addRow();">Add</button></div>
                    </div>
                    <table class="profileTable" id="profile_t">
                        <thead>
                            <tr>
                                <th>&deg;<span class="t_unit">C</span></th>
                                <th>
                                    Condition
                                </th>
                                <th>
                                    Days
                                </th>
                                <th>
                                    SG
                                </th>
                                <th>
                                    Stable
                                </th>
                                <th>
                                    Start Time
                                </th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="stage-temp">19</td>
                                <td>
                                    <div class="for-time">
                                        Ramp
                                    </div>
                                    <div class="condition-con">
                                        <select class="condition">
   <option value="t">Time</option>
   <option value="g">SG</option>
   <option value="s">Stable</option>
   <option value="a">Time & SG</option>
   <option value="o">Time OR SG</option>
   <option value="u">Time OR Stable</option>
   <option value="v">Time & Stable</option>
    <option value="b">SG OR Stable</option>
    <option value="x">SG & Stable</option>
    <option value="w">All</option>
    <option value="e">Either</option>
   </select>
                                    </div>
                                </td>
                                <td class="stage-time">7</td>
                                <td class="stage-sg"></td>
                                <td class="stage-stabletime"></td>
                                <td class="diaplay-time"></td>
                            </tr>
                        </tbody>
                    </table>
                    <div><button id="delbtn" onclick="profileEditor.delRow();">Delete</button>
                        <button id="clearbtn" onclick="profileEditor.clear()">Clear</button>
                        <button id="loadbtn" onclick="PL.toggle()">Load</button>
                        <button id="saveasbtn" onclick="PL.saveas()">Save As</button>
                        <button id="savebtn" onclick="saveprofile()">Save</button></div>
                </div>
                <div id="tc_chart"></div>
            </div>
            <div id="beer-s" class="detail">
                Set Beer Temp:
                    <input type="text" size="6" id="beer-t">&deg;<span class="t_unit">C</span>
            </div>

            <div id="fridge-s" class="detail">
                Set Fridge temp:
                    <input type="text" size="6" id="fridge-t">&deg;<span class="t_unit">C</span>
            </div>
            <div id="off-s" class="detail">
                Turning temperature control <strong>off</strong>.
            </div>
        </div>
    </div>

    <!-- end of bottom frame -->
    <!-- capper -->
    <div class="frame" id="capper-frame">
        <div class="navbar" id="cap-header" class="captimeset">
            <div id="set-mode-text" class="capping-info-pane"> <span>Capping Status:</span>
                <span id="capstate-open" class="capstate">Open</span>
                <span id="capstate-close" class="capstate">Capped</span> @
                <span id="cs-sgcon" class="capstate">gravity &lt;= <span id="capgravityset"></span></span>
                <span id="cs-timecon" class="capstate"><span id="captimeset"></span></span>
                <span id="cs-mancap" class="capstate">Manual capped</span>
                <span id="cs-manopen" class="capstate">Manual Open</span>
            </div>
            <div class="navitems">
                <span class="navitem" id="tab-gravity-m">Gravity</span>
                <span class="navitem" id="tab-time-m">Time</span>
                <span class="navitem" id="tab-manual-m">Manual</span>
                <button id="cap-apply">Apply</button>
            </div>
        </div>

        <div class="tab-containter">
            <div id="tab-gravity-s" class="detail">
                <span>Cap when gravity is less than</span> <input type="text" size="6" id="capgravityinput">
            </div>
            <div id="tab-time-s" class="detail">
                <span>Cap after</span> <input type="text" size="20" id="captimeinput">
            </div>
            <div id="tab-manual-s" class="detail">
                <span>Capped</span> <input type="checkbox" checked="checked" id="capswitch">

            </div>
        </div>
    </div>
    <!-- Dialogs -->
    <div id="dlg_beerprofilereminder" class="modal">
        <div class="modal-content">
            <p>Note:</p> <p>For Beer Profoile to work properly,</p> <p> <strong> Original Gravity Must be specified </strong> if SG is specified as percentage(%), and <strong> Local logging must be activated </strong> if stability of gravity reading is used. </p> Original Gravity:
                <input type="text" size="6">
                <div class="dialog-buttons">
                    <button class="oknog">OK, just Go</button>
                    <button class="ok">Set OG, and Go</button>
                    <button class="cancel">Cancel</button></div>
        </div>
    </div>


    <div id="dlg_loading" class="modal">
        <div class="modal-content">
            <p>
                Communicating with BrewPiLess controller...
            </p>
        </div>
    </div>

    <div id="dlg_addgravity" class="modal">
        <div class="modal-content">
            <span class="message sg">
                Add gravity Record:
            </span>
            <span class="message og">
                Set Original Gravity:
            </span>
            <p>
                Please enter the gravity value.

            </p>
            <ul style="list-style-type: none">
                <li>
                    <input class="sginput" type="text" size="6" value="1.0" onchange="inputsg_change()"> <span class="platounit">&deg;P</span> @
                    <input class="tempinput" type="text" size="6" value="20" onchange="inputsg_change()">
                    <sapn class="temp-unit">&deg;C</sapn>
                </li>
                <li>
                    ~ <span id="sginput-hmc"></span><span class="platounit">&deg;P</span> @ <span id="sginput-hm-cal-temp"></span>
                    <sapn class="temp-unit">&deg;C</sapn>
                </li>
                <li>
                    ~ <span id="sginput-sg-ispindel"></span><span class="platounit">&deg;P</span> @ <span id="sginput-ispindel-temp"></span>
                    <sapn class="temp-unit">&deg;C</sapn>
                </li>
            </ul>

            <div class="dialog-buttons">
                <button onclick="dismissgravity()">Cancel</button>
                <button onclick="inputgravity()">OK</button>
            </div>
        </div>
    </div>

    <div id="dlg_saveas" class="modal">
        <div class="modal-content">
            <span class="message">Save Profile As</span>
            <br><input type="text" size="32">
            <br>
            *No special letters and space allowed.
                <button onclick="PL.cancelSave()">Cancel </button>
                <button onclick="PL.doSave()">OK</button>
        </div>
    </div>


    <div id="profile-list-pane" class="modal">
        <div class="modal-content">
            <h3 class="profile-load-heading">
                Load Profile
            </h3>
            <hr>
            <ul class="profile-list" style="margin:16px 0">
                <li style="margin:8px 0">
                    <button class="rmbutton">Del </button>
                    <a href="#" class="profile-name"></a>
                </li>
            </ul>
            <hr>
            <button class="btn" onclick="PL.toggle()">Cancel</button></div>
    </div>

    <div id="polynomialpane" class="modal">
        <div class="modal-content">
            <div id="xclose" onclick="closepolynomialpane()">X</div>
            <table>
                <tr>
                    <td>
                        <table id="pointlist">
                            <thead>
                                <tr>
                                    <th>
                                        Tilt
                                    </th>
                                    <th>
                                        SG <span class="platounit">&deg;P</span>
                                    </th>
                                    <th>
                                        Calculated
                                    </th>
                                    <th>
                                        Error
                                    </th>
                                    <th>
                                        Ignored
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="pl_calpoint">
                                    <td class="pl_tilt"></td>
                                    <td class="pl_sg"></td>
                                    <td class="pl_value"></td>
                                    <td class="pl_error"></td>
                                    <td><input class="pl_ignored_cb" type="checkbox"></td>
                                </tr>
                            </tbody>
                        </table>
                        <div style="float:right;"><button onclick="applyIgnoreMask()">Apply</button></div>
                    </td>
                    <td>
                        <div id="graph"></div>
                        <span id="polynormial"></span>
                    </td>
                </tr>
            </table>
        </div>
    </div>

</body>

</html>